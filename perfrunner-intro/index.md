![perfrunner](https://habrastorage.org/webt/sx/a0/sh/sxa0shk0u7lgg3hr7zwobnwaeuk.jpeg)

ТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекстТекст

<cut />

## Зачем?

Когда появляется какой-то новый инструмент, самый первый вопрос звучит - зачем? Какую проблему ты пытаешься решить?

Поэтому давайте начнем с проблемы. Был май, я пытался оптимизировать загрузку одного приложения на React.JS и, если честно немного устал. Почему устал? Потому что на каждый чих мне надо было:

- Выбрать параметры сети (например fast-3g)
- Запустить профилирование
- Записать результаты
- Повторить все вышеперечисленное еще два раза, что бы вывести среднюю величину
- Поменять параметры сети на новые
- Повторить все вышеперечисленное еще раз
- Отключить кэш
- Повторить **все вышеперечисленное еще раз**

И так на каждую гипотезу. Понимаете, да? Одно изменение и минимум 12 запусков плюс подсчеты. Тут любой взвоет. Поэтому пока я этим занимался, в голове крутилась мысль что было бы неплохо это как-то автоматизировать. А параллельно, мой коллега подбросил мне один интересный репозиторий, где решалась схожая проблема, но в рамках автотестов. Репозиторий я посмотрел, и все оказалось совсем не сложно. Так и появился Perfrunner.

## Что умеет?

Хотя разработка еще не закончена (есть как минимум одна фича которой мне не хватает), но вот что уже умеет Perfrunner

- Многократное тестирование. По умолчанию, (и в память о моих мучениях), Perfrunner запускает все тесты по 3 раза и агрегирует результат. Это можно поменять так как вам удобно с помощью флага ```--runs```. Валидация выглядит как `requiredPositiveInteger`, так что, теоретически, можно выставить тысяч пять запусков и уйти пить кофе на целый день.
- Эмулирование разных сетевых условий. Сейчас поддерживаются пять вариантов: `online`/`regular-4g`/`fast-3g`/`hspa`/`slow-3g`. Параметры для них я честно нагуглил, так что я не уверен, что они 100% корректны. Если найдется кто-то более сведущий и [поправит](https://github.com/Drag13/perfrunner/blob/development/packages/perfrunner-cli/src/arguments/typeFactories/network.ts) я буду очень благодарен.
- Работа с кэшем или без. Т.е. можно эмулировать и первый заход пользователя и повторный.
- Эмуляция замедления процессора для тестирования на более слабых устройствах. Кстати, чудесная штука. Если никогда не пробовали очень рекомендую поставить где-то на десятикратное замедление и понаблюдать как умирает React. Впрочем, Angular умирает точно так же.

Что действительно полезно, это то, что Perfrunner позволяет просто перечислить параметры сети, указать нужен ли кэш или нет и через несколько минут получить результат.

```cmd
npx drag13.io --network slow-3g fast-3g hspa regular-4g online --cache true false
```

С такими параметрами Perfrunner самостоятельно выполнит 24 прогона сайта, соберет результаты, агрегирует их и выведет в виде HTML отчета.

Кстати, об отчетах. Вот что входит в текущую версию отчета:

- first-contentful-paint, largest-contentful-pain, dom-interactive и еще чуть-чуть. Это нужно что бы понимать как быстро пользователь увидит что-то полезное или сможет взаимодействовать c сайтом.
- layout duration, script duration, recalculate-style-duration. Это нужно что бы смотреть за счет чего у нас улучшаются (или не улучшаются) метрики из первого пункта.
- Размер ресурсов, загруженных до FCP. Это нужно для понимания и контроля сколько ресурсов грузится во время критической секции загрузки.
- Размер всех ресурсов, которые грузит сайт.
- И метки производительности, если они есть.

Все это выводится в виде графиков, и выглядит примерно так:

![perfrunner reporter for the fast-3g](https://habrastorage.org/webt/go/73/qw/go73qwkuckgdg0-6u5_9lhh5yn0.png)

Здесь показано влияние добавление jQuery в мой блог для fast-3g типа сети. Как видите, разница не столь велика (100ms для largest-contentful-paint)

Теперь можно поговорить о том, как это все устроено.

## Как это все устроено?

Собственно, тут все довольно просто. Весь проект написан на TypeScript, код лежит в монорепозитории под управлением Lerna и разбит на 3 отдельных пакета – CLI, Reporters и Core

CLI обслуживает ввод-вывод и основан на [command-line-args](https://www.npmjs.com/package/command-line-args). Из интересного, именно здесь зашиты параметры сетевых условий, например вот так выглядят параметры для `slow3g`:

```javascript
export const Slow3g: NetworkSetup = {
  downloadThroughput: (0.4 * 1024 * 1024) / 8,
  uploadThroughput: (0.4 * 1024 * 1024) / 8,
  latency: 2000,
  name: "slow3g",
};
```

Reporters содержит логику по отображению данных. Здесь лежит код для DefaultHtml, JSON и CSV отчетов. По умолчанию используется DefaultHtml, но с помощью флага `--reporter` можно переключиться на JSON, CSV или даже подключить свой собственный, например вот так:

```javascript
module.exports = (outputFolder, data, args) =>
  console.log(outputFolder, JSON.stringify(data), args);
```

DefaultHtml использует [Chart.JS](https://www.chartjs.org/), который я пытался стилизовать но, видимо, не с моими талантами. Отчет собирается с помощью [Mustache](https://www.npmjs.com/package/mustache) и [Parcel](https://parceljs.org/getting_started.html). Кстати, c Parcel я столкнулся впервые, оказалось очень удобно. TypeScript, бандлинг и минификация поддерживается из коробки. Для инлайнинга (что бы отчет можно было отправить как самостоятельный файл) нашелся плагин [parcel-plugin-inline-source](https://www.npmjs.com/package/parcel-plugin-inline-source). Была и одна неприятная проблема с рендером обратных кавычек (во имя более широкой поддержки среди браузеров, Parcel рендерит ` в виде "), но с помощью костыля это худо-бедно победилось.

Теперь про Core. Он основан на [Puppeter](https://github.com/puppeteer/puppeteer) и отвечает за запуск браузера, сбор метрик и их хранение. Причем, что любопытно, все строится примерно на следующем коде (если упростить):

```javascript
import puppeteer, { Browser, Page } from "puppeteer";

const browser = await puppeteer.launch({ headless: true, timeout: 60000 });
const page = await browser.newPage();
await page.goto(url.href, { waitUntil: "networkidle0" });
const metrics = await page.metrics();
const entries = await page.evaluate(() =>
  JSON.stringify(performance.getEntries())
);
return { metrics, entries };
```

Как видите сама идея проста, но вот что бы довести все до ума, пришлось потрудится.

Каждый тест запускается в новой табе. Метрики собираются с помощью `page.getMetrics()`, `performance.getEntries()` и `performance observers`. Кроме этого, Perfrunner так же собирает трейсы браузера и сохраняет их на диск. Это нужно что бы достать оттуда типы ресурсов (mimetype) и размер переданных по сети файлов (и вообще там много интересного, очень рекомендую покурить трейсы на досуге). Потом результаты агрегируются и считаются средние значения. Затем, уже усредненные значения, с помощью [Lowdb](https://www.npmjs.com/package/lowdb) ложатся в микро JSON базу, а потом оттуда отправляются на визуализацию.

Звучит все не сложно, но, снова-таки были нюансы. Например LargestContentFullPaint нельзя просто взять и вытянуть из `performance.getEntries()`, его там попросту нет. Вместо этого мы должны подписаться на это событие и ждать пока оно прилетит. Что, для моих целей довольно плохо, потому что если на сайте нет JavaScript-а (как например на моем блоге на котором я тестировал), то, внезапно, он в метриках все равно появится. Но, увы, тут или метрику выбрасывать или оверхед терпеть, другого решения я не нашел.

Для тестирования используется стандартная связка chai + mocha которые повешены на `preversion` и `prepublish` хук с помощью [husky](https://www.npmjs.com/package/husky). Кроме этого, с помощью того же hasky и lint-staged, на `prepush` повешен prettier.

## Итоги подведем (С).

Получился простой инструмент для проверки различных гипотез по улучшению производительности. Теперь не надо гадать как влияет critical CSS на рендер конкретно вашего приложения. Добавили, запустили, и через минуты три ответ готов.

На этом, собственно, все. Дополнительные настройки можно посмотреть в [readme](https://www.npmjs.com/package/perfrunner). Фидбек или багу оставить [тут](https://github.com/Drag13/perfrunner). Из следующих планов - поддержка perfrunner.config с кастомными настройками и списком страниц для запуска, рефакторинг и, наверное, commitizen. Если прямо сильно интересно, то апдейты будут в [твиттере](https://twitter.com/drag137). Английская версия статьи лежит [тут](https://drag13.io/posts/perfrunner-intro/index.html).

Надеюсь, этот небольшой проект упростит жизнь не только мне, но и еще нескольким людям которые интересуются и болеют за быстрый веб. Всем добра.