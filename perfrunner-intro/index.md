![perfrunner](https://habrastorage.org/webt/sx/a0/sh/sxa0shk0u7lgg3hr7zwobnwaeuk.jpeg)

Всем, привет. Сегодня хочу поделиться уже своим проектом, который я делал в последние несколько месяцев. Я назвал его Perfrunner и его задача - собирать метрики производительности веб сайта в различных сетевых (и не только) условиях пока я пью кофе. На данный момент реализовано тестирование для эмулированных slow3g, fast3g, и 4g сетей, тестирование с кешированием или без, эмуляция замедления процессора. Собираются события первой и наибольшей отрисовки, время, потраченное на построение макета, и пересчет стилей, размер ресурсов загруженных до FCP и многое другое.

Кому интересны подробности и немного кода, прошу за мной!

<cut />

## Зачем?

Когда появляется какой-то новый инструмент, вопрос номер один это - "Зачем?". Какую проблему ты пытаешься решить?

Поэтому давайте начнем с проблемы. Был май, я пытался оптимизировать загрузку одного приложения на React.JS и, если честно немного устал. Почему устал? Потому что на каждый чих мне надо было:

- Выбрать параметры сети (например fast-3g)
- Запустить профилирование
- Записать результаты
- Повторить все вышеперечисленное еще два раза, что бы вывести среднюю величину
- Поменять параметры сети на новые
- Повторить все вышеперечисленное еще раз
- Отключить кэш
- Повторить **все вышеперечисленное еще раз**

И так на каждую гипотезу. Понимаете, да? Одно изменение и минимум 12 запусков плюс подсчеты. Тут любой взвоет. Поэтому пока я этим занимался, в голове крутилась мысль что было бы неплохо это как-то автоматизировать, но как было не понятно, да и времени не было - нужно было пилить. И тут, мой коллега подбросил мне один очень любопытный репозиторий, где решалась схожая проблема, но для автотестов. Репозиторий я посмотрел, и все оказалось совсем не сложно. Так и появился Perfrunner инструмент, который упрощает тестирование гипотез по улучшению (или как повезет) производительности для веб сайтов и веб приложений.

## А с тебя какая польза?

Хотя разработка еще не закончена (есть как минимум одна фича которой мне не хватает), но вот что уже умеет Perfrunner

- Многократное тестирование. По умолчанию, (и в память о моих мучениях), Perfrunner запускает все тесты по 3 раза и агрегирует результат. Если нравится другое число, значение можно поменять с помощью флага ```--runs```. Валидация выглядит как `requiredPositiveInteger`, так что, теоретически, можно выставить тысяч пять запусков и уйти пить кофе на целый день.
- Эмулирование разных сетевых условий. Сейчас поддерживаются пять вариантов: `online`/`regular-4g`/`fast-3g`/`hspa`/`slow-3g`. Параметры для них я честно нагуглил, так что я не уверен, что они 100% корректны. Если найдется кто-то более сведущий и [поправит](https://github.com/Drag13/perfrunner/blob/development/packages/perfrunner-cli/src/arguments/typeFactories/network.ts) я буду очень благодарен.
- Работа с кэшем или без. Т. е. можно эмулировать и первый заход пользователя и повторный.
- Эмуляция замедления процессора для тестирования на более слабых устройствах. Кстати, чудесная штука. Если никогда не пробовали очень рекомендую поставить где-то на десятикратное замедление и понаблюдать как умирает React. Впрочем, Angular умирает точно так же.

Что действительно полезно, это то, что Perfrunner позволяет просто перечислить набор параметров (варианты сети, кэш) и через несколько минут получить результат. Выглядит это вот так:

```cmd
npx drag13.io --network slow-3g fast-3g hspa regular-4g online --cache true false
```

С такими параметрами Perfrunner самостоятельно выполнит 24 прогона сайта, соберет результаты, агрегирует их и выведет в виде HTML отчета. Согласитесь, намного проще чем делать все вручную.

Теперь об отчетах. Вот что входит в текущую версию отчета:

- first-contentful-paint, largest-contentful-pain, dom-interactive и еще чуть-чуть. Это нужно что бы понимать как быстро пользователь увидит что-то полезное или сможет взаимодействовать c сайтом.
- layout duration, script duration, recalculate-style-duration. Это нужно что бы смотреть за счет чего у нас улучшаются (или не улучшаются) метрики из первого пункта.
- Размер ресурсов, загруженных до FCP. Это нужно для понимания и контроля сколько ресурсов грузится во время критической секции загрузки.
- Размер всех ресурсов, которые грузит сайт.
- И метки производительности, если они есть.

Все это выводится в виде графиков (кликабельно):

[![perfrunner reporter for the fast-3g](https://habrastorage.org/webt/go/73/qw/go73qwkuckgdg0-6u5_9lhh5yn0.png)](https://drag13.io/original.94c91eda.png)


Здесь показано как изменяетются метрики после добавления jQuery в шапку страницы. Точно так же можно тестировать любые другие гипотезы, например влияние внедрения критического CSS в index.html для SPA приложений, использование директив preload и prefetch, lazy-loading и все остальное. Причем! Вы увидите не только то, как изменились метрики для вашего любимого 100мбит канала, но и, например, для slow-3g (а там все со-о-о-о-всем по-другому).

С пользой вроде бы разобрались, теперь можно поговорить о том, как это все устроено.

## Как это все устроено?

На самом деле все довольно просто. Весь проект написан на TypeScript, код лежит в монорепозитории под управлением Lerna и разбит на 3 отдельных пакета – CLI, Reporters и Core

CLI обслуживает ввод-вывод и основан на [command-line-args](https://www.npmjs.com/package/command-line-args). Из интересного, именно здесь зашиты параметры сетевых условий, например вот так выглядят параметры для `slow3g`:

```javascript
export const Slow3g: NetworkSetup = {
  downloadThroughput: (0.4 * 1024 * 1024) / 8,
  uploadThroughput: (0.4 * 1024 * 1024) / 8,
  latency: 2000,
  name: "slow3g",
};
```

Reporters содержит логику по отображению данных. Здесь лежит код для генерации HTML, JSON и CSV отчетов. По умолчанию используется HTML отчет, но с помощью флага `--reporter` можно переключиться на JSON, CSV или даже подключить свой собственный, например вот так:

```javascript
//reporer.js
module.exports = (outputFolder, data, args) =>
  console.log(outputFolder, JSON.stringify(data), args);
```

```cmd
npx perfrunner drag13@io --reporter "./reporter.js"
```

Для генерации HTML отчета я использовал [Parcel](https://parceljs.org/getting_started.html) и [Mustache](https://www.npmjs.com/package/mustache). Кстати, c Parcel я столкнулся впервые, оказалось очень удобно. TypeScript, бандлинг и минификация поддерживается из коробки. Для инлайнинга (что бы отчет можно было отправить как самостоятельный файл) нашелся плагин [parcel-plugin-inline-source](https://www.npmjs.com/package/parcel-plugin-inline-source). Была и одна неприятная проблема с рендером обратных кавычек (во имя более широкой поддержки среди браузеров, Parcel рендерит ` в виде "), но с помощью костыля это худо-бедно победилось. Для вывода графиков я взял [Chart.JS](https://www.chartjs.org/), который пытался стилизовать но, безуспешно, дизайнер во мне явно мертвее мертвого.

Ну и теперь про Core. Он основан на [Puppeter](https://github.com/puppeteer/puppeteer) и отвечает за запуск браузера, сбор метрик и их хранение. Причем, что любопытно, все строится примерно на следующем коде (если упростить):

```javascript
import puppeteer, { Browser, Page } from "puppeteer";

const browser = await puppeteer.launch({ headless: true, timeout: 60000 });
const page = await browser.newPage();
await page.goto(url.href, { waitUntil: "networkidle0" });
const metrics = await page.metrics();
const entries = await page.evaluate(() =>
  JSON.stringify(performance.getEntries())
);
return { metrics, entries };
```

Как видите, идея довольно проста, но вот что бы довести все до ума, пришлось потрудится.

Каждый тест запускается в новой табе. Метрики собираются с помощью `page.getMetrics()`, `performance.getEntries()` и `performance observers`. Кроме этого, Perfrunner так же собирает трейсы браузера и сохраняет их на диск. Это нужно что бы достать оттуда типы ресурсов (mimetype) и размер переданных по сети файлов (и вообще там много интересного, очень рекомендую покурить трейсы на досуге). Потом результаты cобираются и считаются средние значения. Затем, уже усредненные значения, с помощью [Lowdb](https://www.npmjs.com/package/lowdb) ложатся в микро JSON базу, а потом отправляются на визуализацию.

Теперь про нюансы. Вот, например LargestContentFullPaint нельзя просто взять и вытянуть из `performance.getEntries()`, его там попросту нет. Вместо этого мы должны подписаться на это событие и ждать пока оно прилетит. Что, для моих целей довольно плохо, потому что если на сайте нет JavaScript-а (как например на моем блоге, на котором я тестировал), то, внезапно, он в метриках все равно появится. Но, увы, тут или метрику выбрасывать или оверхед терпеть, другого решения я не нашел. Еще, из любопытного, это обязательный прогрев Хрома перед тестированием (причем, даже если кэш не нужен, все равно нужно прогревать иначе первые значения очень завышены). Был еще веселый случай, который почти свел меня с ума на часа три. В случайном порядке один из запусков, иногда, выдавал цифры в два раза хуже, чем остальные тесты (причем уже после прогрева). Трейсы показывали аномально высокие значение TTFB, а именно Stalled часть, которая могла длиться 1200-1500ms. Проблема оказалось в использовании Proxy, которая почему-то включилась на Windows машине. Поседеть я не поседел, но wtf/sec был около 2.

Для тестирования я взял стандартная связка chai + mocha которые повешены на `preversion` и `prepublish` хук с помощью [husky](https://www.npmjs.com/package/husky). Кроме этого, с помощью того же hasky и lint-staged, на `prepush` повешен prettier. Покрыто далеко не все, и код совсем не идеален, но он работает и приносит пользу (как минимум мне). Для CI/CD - традиционно взят Travis CI.

## Итоги подведем (С).

Получился простой инструмент для проверки различных гипотез по улучшению производительности. Теперь не надо гадать сколько стоит убрать jQuery или добавить внедрить critical CSS в приложение. Добавили, запустили, и через минуты три ответ готов.

На этом, собственно, все. Дополнительные настройки можно посмотреть в [readme](https://www.npmjs.com/package/perfrunner). Фидбек или багу оставить [тут](https://github.com/Drag13/perfrunner). Из следующих планов - поддержка perfrunner.config с кастомными настройками и списком страниц для запуска (ETA - конец августа), рефакторинг и, наверное, commitizen. Если прямо сильно интересно, то апдейты будут в [твиттере](https://twitter.com/drag137). Английская версия статьи лежит [тут](https://drag13.io/posts/perfrunner-intro/index.html).

Надеюсь, этот небольшой проект упростит жизнь не только мне, но хотя бы еще нескольким людям, которые интересуются и болеют за быстрый веб. Всем добра.

P.S. Cпасибо veri-ivanova за КДПВ и raharrison за работающий пример.