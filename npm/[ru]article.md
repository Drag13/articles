Всем привет. Недавно мне попалась задача настроить приватный npm реестр и интегрировать его в билд процессы одного клиента. Все звучало очень пафосно и интересно, пока не оказалось что делать там нам самом деле почти нечего. Клиент сидит под VSTS, а VSTS из-коробки умеет раздавать приватный реестр для NPM (и не только для него, но мы тут не за рекламой). И статья бы не появилось, если бы потом не возникла вторая задача - написать максимально настроенный модельный npm пакет который можно было бы взять, склонировать и на его базе быстро создать какой-то действительно полезный пакетец. Если вам интересно, что в итоге получилось - прошу под кат. 

</cut>

# Анализ требований

Ок, подумал я. Что нам известно? 

* Новые проекты у клиента пишутся на TypeScript
* Кроме новых проектов, есть еще куча проектов на чистом JavaScript
* Фреймворки используются какие бог на душу положит
* Тесты быть должны

Вроде бы все. Какие можно сделать выводы? 

* Модуль должен быть на TypeScript
* Модуль должен быть используемым из-под typescript и из-под javascript
* Тесты должны быть

Вроде бы все. Это будут наши минимальные требования. Но мы же умные, раз это модельный пакет, значит мы можем сделать немножечко больше. После некоторых раздумий требования превратились в такие:

* Модуль должен быть на TypeScript и проверен с помощью TsLint
* Модуль должен быть используемым из-под TypeScript и из-под JavaScript
* Тесты должны быть настроены на git hook, минимальное покрытие кода должно быть тоже настроено
* Форматирование должно быть настроено
* Документация должна генериться из кода
* Публикация должна быть удобной и единообразной
* Все что можно должно быть автоматизировано

Вот теперь все, можно делать.

## Предварительные телодвижения

Создаем (клонируем) репозиторий, инициализируем npm пакет, ставим локально TypeScript. Вообще все зависимости ставим локально, и не забываем фиксировать их версии. 


```cmd
git init
npm init
npm i typescript -D
./node_modules/.bin/tsc --init
```

Тут же на месте исправляем tsconfig.json под себя - выставляем target, libs, include/exclude, outDir опции.

## Стиль форматирования - editorconfig || prettier

Если вы не хотите выслушивать споры что лучше - пробелы (и сколько) или табы, то лучше пресечь это все и попросту убить альтернативу на корню. Для этого есть общепризнанная тула
тула [prettier](), которая отлично интегрируется с eslint. Но у нас typescript и с tslint prettier может/будет конфликтовать. Так что у меня было три варианта

* забить
* самостоятельно отрезолвить конфликты, зафиксировать их в .prettierrc и поддерживать это все добро всю оставшуюся жизнь
* использовать уже готовый npm пакет [tslint-config-prettier](https://github.com/alexjoverm/tslint-config-prettier) и надеятся что владелец через три месяца не пойдет в п.1

Мне не очень хочется это все поддерживать так что я выбрал первый вариант, но подстраховался с помощью [.editorconfig](https://editorconfig.org/). У него очень неплохая поддержка среди IDE так что как минимум автоформатирование у нас будет единообразное, а об остальном должен позаботиться tslint. Поэтому я просто добавил .editorconfig в проект и успокоился

```yml
#root = true

[*]
indent_style = space
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
max_line_length = 100
indent_size = 4

[*.md]
trim_trailing_whitespace = false
```

## Стиль кодописания - tslint || eslint

За стиль кодописания (например, надо ли ставить точку с запятой в конце выражения или обораичвать единственный аргумент лямбды в скобки) у нас будет отвечать tslint (для JS проектов есть eslint). Ставим его и инициализируем. 

```cmd
npm i tslint -D
./node_modules/.bin/tslint --init

```

И теперь обновим наш package.json первой полезной командой

```json
scripts: {
    "lint": "./node_modules/.bin/tslint -c tslint.json 'src/**/*.ts' 'tests/**/*.spec.ts'",
}
```

При запуске, он возьмет правила из tslint.json и применит их к файлам в src и tests папкам. Если что-то пойдет не так, он вернет ошибку. Кстати ему можно передать параметр --fix и он попробует самостоятельно исправить ошибки.

## Тесты karma || chai

CodeStyle выбран, теперь нам нужны тесты. Ставим karma (chai), jasmine и соответствующий обвес для того что бы подружить их typescript:

```cmd
    npm i karma karma-chrome-launcher karma-typescript karma-jasmine jasmine @types/jasmine -D
    ./node_modules/.bin/karma init
```

Незабудьте указать в karma.conf.js plugins и frameworks, иначе не взлетит и обновить scripts секцию package.json новыми командами

```json
    "karma": "./node_modules/.bin/karma",
    "test": "npm run karma -- start"
```

Если вы планируете использовать CI, то лучше поставить HeadlessChrome:

```cmd
    npm i puppeteer -D
```

И в karma.conf.js исправить Chrome на ChromeHeadless в browsers. Для travis-ci, придется еще поправить .travis.yml файл (как именно посмотреть можно в демо репозитории). Threshold уровень задается в karmaTypescriptConfig.coverageOptions.threshold. Документация лежит [здесь](https://www.npmjs.com/package/karma-typescript)

Ну и осталось проверить что у нас все запускается. Создайте index.ts в src папке и index.spec.ts в папке dist. Добавьте туда какой нибудь код и какой нибудь тест. В конце концов всем понятно что код тут совсем не причем и запустите npm test. Если все сделано правильно, вы увидите результат тестов и отчет по покрытию кода. Кстати, не забудьте обновить .gitignore и выбросить папку coverage из-под контроля версий. 

## Документация

Тепер к документации. Документации у нас будет две. Первая это документация из-кода, вторая - документация из коммитов. Для документации из кода я взял typedoc (аналог [esdoc](https://esdoc.org/) но для typescript). Он очень просто ставится и работает. Главное не забудьте убрать результаты его трудов из-под контроля версий.

```cmd
npm i typedoc -D
```

и обновляем package.json 

```json
"doc": "./node_modules/.bin/typedoc --out docs/ src/ --readme ./README.md"
```

Запускаем, проверяем:

```cmd
npm run doc
```

Второй тип документации это changelog. Для него мы возьмем [commitizen](https://github.com/commitizen/cz-cli). Сразу предупреждаю, штука своеобычная, может не зайти. Из плюсов - заставляет писать коммиты в одном стиле, который поддерживается conventional-changelog. Если вы видели changelog ангуляра - это оттуда. Надо ли оно вам - вопрос сложный. Если вы хотите формализировать коммиты команды - тогда надо. Только ради лога изменений я бы его не брал. Итак потихоньку в монстра превращаемся. Кстати для VsCode есть [плагин](https://github.com/KnisterPeter/vscode-commitizen)

## Билд

Тут все достаточно тривиально

В tsconfig.json выставляем флаг declaration в true 

Добавляем команду в package.json 

```json
"build": "./node_modules/.bin/tsc --p ./ --sourceMap false --removeComments true"
```

и добавляем новую секцию files в package.json 

```json
 "files": [
    "dist/",
    "docs/",
    "src/",
    "tests/"
  ],
```

Эта секция нужна для того, что бы указать npm какие файлы включать в паблиш. По-умолчанию, npm руководствуется .gitignore и .npmignore файлами для того что бы не заливать мусор в релиз. Но с помощью секции files мы можем перееопределить поведение по умолчанию и явно задать какие файлы потребуются клиенту. Для нас это возможность включить билд артефакты в релиз и не хранить их под контролем версий. Кстати, кроме файлов указанных в files, npm в любом случае добавит еще сам package.json, readme.md, changelog.md и несколько других так что о них беспокоится не надо. 

## Публикация 

Для правильной публикации нам нужно собрать проект и пересоздать документацию. Можно делать это все руками, можно автоматизировать. Начнем с того что используем npm хук prepublish. Для этого добавим в scripts вот такую команду:

```json
"prepublish": "call npm run build && call npm run doc"
```

В зависимости от версии npm prepublish комманда может себя вести немного по разному в частности запускаться во время npm install, но в 5ой версии все должно быть уже ок. 


## Автоматизация

Остался последний шаг. Автоматизация всего что мы тут настроили. Для этого нам пригодятся githooks и cli для работы с ними - Husky. Его идея в том, что он перехватывает git события и выполняет сопоставленные им комманды из package.json. Очень удобно тем, что позволяет на уровне репозитория настроить все проверки еще до того как ваш коммит попадет в общую сборку. Кроме того, можно поставить еще и lint-staged пакет, который позволяет запускать линтер только на staged файлах. Это быстрее и гарантирует то, что именно staged версия файлов валидна.

```cmd
npm i lint-staged husky -D
```

Снова обновляем секцию scrpitps нашего многострадалього package.json: 

```json
"precommit": "call npm run lint-staged && call npm test",
"prepush": "call npm run lint && call npm test && call npm run build"

```

Вот и все. 

## Оглянемся?

А теперь давайте оглянемся что же мы сделали. Для того что бы подготовить репозиторий под разработку "по модньому (-укр)" мы поставили ___ пакетов. 


## Bonuses

В качестве бонуса есть демо репозиторий, который все это поддерживает + CI с помощью travis-ci. Вдруг что - пользуйтесь. 


Еще есть такая тула как commitizen. Помогает писать коммиты в одном стиле. У меня такого требования не стояло, так что я не стал ее сюда добавлять но почитать о ней можно тут. Еще интересно что она поддреживает conventional changelog формат и, значит с ней могут работать другие инструменты которые его понимают. 

Еще одна полезная вещь это lint-staged