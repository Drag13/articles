Делаем демо npm пакет для своей организации.

Нам нужно. 

* Стиль форматирования
* Стиль кода 
* Тесты
* Документация
* Публикация
* Автоматизация безобразия

## Предварительные телодвижения

Создаем (клонируем) репозиторий, инициализируем npm пакет, ставим typescript (локально!). Если вдруг у вас нет node и npm (зачем тогда вообще это все?) ставим еще node.js

```
git init
npm init
npm i typescript -D
./node_modules/.bin/tsc --init
```

Рекомендую сразу поправить tsconfig.json - выставить target, libs, include/exclude, outDir опции. 

## Стиль форматирования

Если вы не хотите выслушивать споры что лучше - пробелы (и сколько) или табы, то лучше пресечь это все и попросту убить альтернативу на корню. Для этого есть общепризнанная тула
тула [prettier](), которая отлично интегрируется с eslint. Но у нас typescript и с tslint (аналог eslint для typescript) она будет конфликтовать. Так что если вы пишете на TS есть три варианта - 

* забить
* самостоятельно отрезолвить конфликты и зафиксировать их в .prettierrc и поддерживать это все добро всю оставшуюся жизнь
* использовать уже готовый npm пакет [tslint-config-prettier](https://github.com/alexjoverm/tslint-config-prettier) и надеятся что владелец через три месяца не пойдет в п.1

Мне не очень хочется это все поддерживать так что я выбрал первый вариант, но подстраховался с помощью [.editorconfig](https://editorconfig.org/). У него очень неплохая поддержка среди IDE так что как минимум автоформатирование у нас будет единообразное, а об остальном позаботится tslint.

Вот пример моего .editorconfig: 

```
#root = true

[*]
indent_style = space
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
max_line_length = 100
indent_size = 4

[*.md]
trim_trailing_whitespace = false
```

## Стиль кодописания

За стиль кодописания (например, надо ли ставить точку с запятой в конце выражения или обораичвать единственный аргумент лямбды в скобки) у нас будет отвечать tslint. Ставим его и инициализируем. 

```
npm i tslint -D
./node_modules/.bin/tslint --init

```

И теперь обновим наш package.json первой полезной командой

```
scripts: {
    "lint": "./node_modules/.bin/tslint -c tslint.json 'src/**/*.ts' 'tests/**/*.spec.ts'",
}
```

## Тесты

CodeStyle выбран, теперь нам нужны тесты. Ставим karma, jasmine и соответствующий обвес для того что бы подружить их typescript:

```
    npm i karma karma-chrome-launcher karma-typescript karma-jasmine jasmine @types/jasmine -D
    ./node_modules/.bin/karma init
```

Незабудьте указать в karma.conf.js plugins и frameworks, иначе не взлетит и обновить scripts секцию package.json новыми командами

```
    "karma": "./node_modules/.bin/karma",
    "test": "npm run karma -- start"
```

Если вы планируете использовать CI, то Chrome вам не подойдет, нужно ставить HeadlessChrome:

```
    npm i puppeteer -D
```

И в karma.conf.js исправить Chrome на ChromeHeadless в browsers.

Тесты есть, давайте их проверим. Создайте index.ts в src папке и index.spec.ts в папке dist. Добавьте туда какой нибудь код и какой нибудь тест. В конце концов всем понятно что код тут совсем не причем и запустите npm test. Если все сделано правильно, вы увидите результат тестов и отчет по покрытию кода. Кстати, не забудьте обновить .gitignore и выбросить папку coverage из-под контроля версий. 

## Документация

Пришло время писать документацию. И самый лучший способ ее писать - заставить это сделать кого-то другого. Например машину. 
Ставим typedoc (аналог [esdoc](https://esdoc.org/) для typescript)

```
    npm i typedoc -D
```

и обновляем package.json 

```
    "doc": "./node_modules/.bin/typedoc --out docs/ src/ --readme ./README.md"
```

Запускаем, проверяем:

```
    npm run doc
```

## Билд

Здесь два варианта. Ничего не делать. Мы отдаем только .ts файлы, все остальное - билд, минификация и кто еще что придумает остается на совести потребителя. Подход прекрасный, практически SRP, но с таким подходом нашу библиотеку будет очень не удобно использовать из-под javascript. А это в общем-то некрасиво. Поэтому, мы можем собрать наш билд самостоятельно. А блоагодаря d.ts файлам его результат будет легко использовать и typescript проектам. Одним выстрелом двоих зайцев. Единственный минус такого подхода, придется держать билд артефакты под контролем версий. (????)


Добавляем команду в package.json 

```
    "build": "./node_modules/.bin/tsc --p ./ --sourceMap false --removeComments true"
```

В tsconfig.json выставляем declaration в true

## Публикация 

SKIP

## Автоматизация

Остался последний шаг. Автоматизация всего что мы тут настроили. Для этого нам пригодятся githooks и cli для работы с ними - Husky.

```
    npm i lint-staged husky -D
```

lint-staged это еще один пакет, который запускает линтер только на staged файлах. Это полезно так как позволяет быть уверенным, что файлы которые уходят в коммит действительно валидны.

package.json: 

{
    "husky": {
        "hooks": {
            "pre-commit": "npm run precommit",
            "pre-push": "npm run precommit"
        }
    },
    scripts: {
        "precommit": "call npm run lint && call npm test && call npm doc"
    }
}

Вот и все. 


Незабудьте выкосить всякие крышечки (^ ~) из ваших зависимостей, скажем нет неопределившимся зависимостям. 

## Bonuses

Еще есть такая тула как commitizen. Помогает писать коммиты в одном стиле. У меня такого требования не стояло, так что я не стал ее сюда добавлять но почитать о ней можно тут. Еще интересно что она поддреживает conventional changelog формат и, значит с ней могут работать другие инструменты которые его понимают. 

Еще одна полезная вещь это lint-staged