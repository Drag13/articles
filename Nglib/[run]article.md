# Пробуем создать библиотеку компонент для Angular с помощью AngularCli

## Проблема

Когда проектов становится чуть больше чем один, возникает необходимость как-то переиспользовать не только отдельные модули с кодом, но и сами UI-компоненты. Вариантов решения проблемы много - от традиционного копипаста, до настройки отдельного проекта с тестами, документацией и блекджеком на выбор.

Проблема в том, что второй вариант требует значительных усилий по подготовке и каждый такой проект уникальный - со своим инструментарием в котором каждому новому разработчику нужно разбираться заново. В конце июля, команда Angular предложила свое решение этой проблемы добавив в angular/cli новую команду для создания библиотек - library.

Давайте проверим, что из этого получилось.

<cut/>

## Идеальный мир

В идеальном мире все должно быть удобно. Так, для библиотеки компонент я бы выделил три важных момента

* Единообразность и быстрый старт
* Удобство разработки
* Удобство распространения

## Итак начем со старта

Для того что бы создать свою библиотеку нам нужно сделать два шага - создать проект и сгенерировать библиотеку. Сначала создадим новый проект:

```cmd
npx @angular/cli@latest new mylibapp
```

<spoiler title="npx">
Я использую npx что бы не устанавливать cli глобально и избегать npm run конструкций. Если у вас npm версии 5.2 или новее - попробуйте. Подробнее почитать можно [здесь](https://blog.scottlogic.com/2018/04/05/npx-the-npm-package-runner.html)
</spoiler>

После выполнения команды, мы увидим стандартный (для 6 ангуляра, который отличается от 5ой версии) проект в котором будут созданы два под-проекта - основной mylibapp и mylibapp-e2e. Сам angular проект теперь описывается в angular.json.

Библиотеки, как видим, пока нет.

И вот он первый нюанс. Наше название уже занято основным проектом, и назвать библиотеку так же уже не выйдет. Поэтому, если вы хотите назвать свою библиотеку my-super-library, сначала вам нужно создать проект, который должен называться как-то по-другому. Например, my-super-library-project. И только потом, создавать библиотеку с желаемым названием.

Теперь создадим третий под-проект и сгенерируем библиотеку.

```cmd
cd mylibapp
npx ng generate library mylib --prefix mlb
```

Указывать префикс не обязательно, но очень желательно что бы не пересекаться с другими библиотеками.

Наконец, третьим под-проектом, появляется наша библиотека. Она имеет свой отдельный package.json, tsconfig и karma.conf.js что радует. Но почему ее нельзя было сделать совсем отдельным проектом (как например в .Net) я не знаю. И если e2e проект не сложно удалить руками, то основной проект - уже нет. В итоге у нас появляется лишний код, что не очень хорошо.

Теперь давайте посмотрим, какие инструменты мы получаем сразу. Это связка tslint + codelyzer, karma + jasmine и protractor для e2e. Т.е. стандартный набор, ничего специфичного для библиотеки нам не подвезли, что немного странно так как как для библиотеки UI компонентов я бы ожидал какой-то инструмент для документации и просмотра, что-то вроде [storybook](https://github.com/storybooks/storybook). Но ладно, будем считать, что тут нам просто оставили пространство для маневра.

Давайте запустим тесты и линтер что бы убедиться, что все работает.

```cmd
npm test mylib
npx ng lint mylib
```

У меня все прошло без проблем, но для тестирования был использован Chrome, что тоже странно. Я ничего против него не имею, но на билд серверах его на 90% не будет. Почему не использовали тот же Puppeteer - не понятно.

Подведем итоги:

Плюсы

* Быстрый старт нового проекта
* Единообразный подход

Минусы

* Лишний код в проекте
* Очевидные вещи нужно допиливать руками

Ничего критичного, продолжаем копать дальше.

## Разработка

Кое-какие компоненты у нас уже есть "из коробки", хотелось бы на них посмотреть. Как это сделать? Поскольку никаких специальных инструментов у нас нет, будем использовать основной проект (вот он оказывается зачем нужен). Для этого нам нужно сбилдить библиотеку, сделать импорт библиотечного модуля и запустить основной проект.

<spoiler title="немного кода">

```cmd
npx ng build mylib
```

```javascript
import { MylibModule } from "mylib";

...

@NgModule({
  declarations: [
    AppComponent,
  ],
  imports: [
    BrowserModule, MylibModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
```

```cmd
npm start
```

</spoiler>

После того как все выполнится, мы увидим наш компонент из библиотеки. Но снова есть нюанс - watch режим для библиотеки пока не сделали, нужно каждый раз запускать билд библиотеки самостоятельно? Watch появится только в angular/cli 6.2+. И не из коробки, для этого придется добавить новый флаг в tsconfig.json

tsconfig.json

```json
"angularCompilerOptions": {
    "enableResourceInlining": true,
}
```

А после этого запускать билд c флагом watch:

```cmd
ng build mylib --watch
```

Если же вы в силу каких-то причин будете использовать cli младше 6.2, билдить придется самостоятельно.

Теперь давайте добавим новый компонент. Для этого нужно выполнить стандартную команду generate component. Из-за того, что библиотека не наш основной проект, приходится использовать флаг проекта, что немного раздражает (ах, если бы библиотека была самостоятельным решением...).

```cmd
npx ng generate component some-nice-image --project mylib
```

Теперь под mylib/src создадим папку assets, добавим картинку и снова пересоберем библиотеку что бы увидеть резульат. И тут нас ждет еще один сюрприз - картинки нет. Оказывается, что ресурсы, используемые в библиотеке не попадают в билд автоматически, их нужно копировать самостоятельно (или [вот так](https://github.com/ng-packagr/ng-packagr/issues/123#issuecomment-398559176)). И вроде бы не страшно, но все равно как-то не правильно.

Зато, из-коробки должен работать tree-shaking. Давайте создадим еще один компонент в библиотеке но не будем использовать его в основном проекте. Собираем **основной проект** в продакш режиме

```cmd
npx build --prod
```

И видим, что размер бандла не изменился. Tree-Shaking с библиотеками действительно работает!

Теперь неплохо было бы попробовать поставить какую-то зависимость. Поскольку каждый проект имеет свой собственный package.json нам нужно сначала перейти в папку библиотеки и выполнять команду npm install

```cmd
npm i -D @drag13/when-do
npm i @drag13/round-to
```

Я специально поставил их по-разному что бы проверить как потом с этим справится упаковщик. Все ставится без проблем. Пробуем собрать и получаем предупреждение

> Distributing npm packages with 'dependencies' is not recommended. Please consider adding @drag13/round-to to 'peerDependencies'or remove it from 'dependencies
 
*Распространение npm пакетов с зависимостями не желательно. Пожалуйста, подумайте, что бы добавить зависимость @drag13/round-to к peerDependencies или вообще убрать ее из зависимостей*

а, затем, и ошибку:
> Dependency @drag13/round-to must be explicitly whitelisted

*Зависимость @drag13/round-to должна быть явно добавлена в белый список*

Вот это уже интересно, by design, библиотека не хочет иметь прямых зависимостей. Пробуем переместить нашу зависимость в секцию peerDependencies и собраться заново – вуаля, все работает. Но это значит порядок установки сторонних библиотек теперь другой. Сначала ставим зависимость на основной модуль, потом, ручками добавляем в секцию peerDependencies библиотеки.

Остальное работает так же, как и в обычном Angular проекте.

Коротко подведем итоги:

Плюсы:

* Работаем в знакомом окружении со знакомыми командами
* Есть tree-shaking из коробки

Минусы:

* Для "посмотреть компонент" нужно использовать целый проект
* Пока еще нет watch режима
* Ресурсы нужно копировать вручную или настраивать билд-процесс самостоятельно.

И, наконец, переходим к публикации

## Публикация

Вот тут все прямо хорошо. Для публикации angular/cli использует уже неплохо зарекомендовавший себя [ng-packgr](https://github.com/ng-packagr/ng-packagr) который самостоятельно собирает наш код в пригодный для публикации npm пакет оставляя за бортом настройку package.json файла (а это не мало), минификацию, упаковку в разные форматы (например в UMD). 

Для того, чтобы опубликовать свой пакет (или посмотреть что там внутри) нужно выполнить три команды

```cmd
npx ng build --prod
cd dist/mylib
npm publish
```

Если вы не хотите паблишить, замените команду publish на pack

В результате у меня получилось следующее

Для начала давайте заглянем в package.json, который выглядит совсем не так оригинальный package.json нашей библиотеки.
 
<spoiler title="немного кода">

```json
{
  "name": "mylib",
  "version": "0.0.1",
  "peerDependencies": {
    "@angular/common": "6.1.6",
    "@angular/core": "6.1.6",
    "@drag13/round-to": "^0.10.1"
  },
  "devDependencies": {
    "@drag13/when-do": "^1.1.0"
  },
  "dependencies": {
    "tslib": "^1.9.0"
  },
  "main": "bundles/mylib.umd.js",
  "module": "fesm5/mylib.js",
  "es2015": "fesm2015/mylib.js",
  "esm5": "esm5/mylib.js",
  "esm2015": "esm2015/mylib.js",
  "fesm5": "fesm5/mylib.js",
  "fesm2015": "fesm2015/mylib.js",
  "typings": "mylib.d.ts",
  "metadata": "mylib.metadata.json",
  "sideEffects": false
}
```

</spoiler>

Как видим, packagr не стал удалять наши devDependencies, хотя некоторые так делают. Кроме того радует количество форматов, которые поддерживает описаны в package.json (пусть я и половины их не знаю). Внутри пакет содержит минифицированный и не минифицированный бандл в формате UMD, и еще несколько бандлов внутреннего формата angular (fesm5, fesm2015). Но, главное, что это убрали за пределы внимания разработчиков, что просто огромный плюс.

Перейдем к выводам

Плюсы:

* Удобство
* Продуманность

Минусов:

* Не заметил

## Итоги

Команда Angular сделала очень интересную попытку унифицировать создание библиотек компонент и упростить разработчикам жизнь. Получилось это или нет каждый волен решать сам, но на мой взгляд решение пока сыровато, хотя и решает больше количество проблем - таких как унификация и публикация. К сожалению, библиотека не является самостоятельным проектом by design, что сказывается уже и еще скажется в будущем. Однако, я уверен, что со временем мы получим отличный инструмент для разработки.