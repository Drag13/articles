# Пробуем создать библиотеку компонент для Angular с помощью AngularCli

## Проблема

Когда проектов становится чуть больше чем один, возникает необходимость как-то переиспользовать не только отдельные модули с кодом, но и сами UI-компоненты. Вариантов решения проблемы много - от традиционного копипаста, до настройки отдельного проекта с тестами, документацией и блекджеком на выбор.

Проблема в том, что второй вариант требует значительных усилий по подготовке и каждый такой проект уникальный - со своим инструментарием в котором каждому новому разработчику нужно разбираться заново. В конце июля, команда Angular предложила свое решение этой проблемы добавив в angular/cli новую команду для создания библиотек - library.

Давайте проверим, что из этого получилось.

<cut/>

## Идеальный мир

В идеальном мире все должно быть удобно. Так, для библиотеки компонент я бы выделил три важных момента

* Единообразность и быстрый старт
* Удобство разработки
* Удобство распространения

## Итак начем со старта

Для того что бы создать свою библиотеку нам нужно сделать два шага - создать проект и сгенерировать библиотеку. Сначала создадим новый проект:

```cmd
npx @angular/cli@latest new mylibapp
```

<spoiler title="npx">
Я использую npx что бы не устанавливать cli глобально и избегать npm run конструкций. Если у вас npm версии 5.2 - попробуйте. Подробнее почитать можно [здесь](https://blog.scottlogic.com/2018/04/05/npx-the-npm-package-runner.html)
</spoiler>

 После выполнения команды, мы увидим стандартный (для 6 ангуляра, который отличается от 5ой версии) проект в котором будут созданы два подпроекта - основной mylibapp и mylibapp-e2e. Библиотеки пока нет.

Вот он первый нюанс. Если вы хотите назвать свою библиотеку my-super-library, сначала вам нужно создать проект который должен называться как-то по-другому. Например my-super-library-project. И только потом, создавать библиотеку с вашим желаемым названием.

Теперь создадим третий подпроект и сгенерируем библиотеку.

```cmd
cd mylibapp
npx ng generate library mylib --prefix mlb
```

Указывать префикс не обязательно, но желательно что бы не пересекаться с другими библиотеками.

Наконец, третьим подпроетком, появляется наша библиотека. Почему ее нельзя было сделать отдельным проектом (как например в .Net) я не знаю. И если e2e проект не сложно удалить руками, то основной проект - уже нет. В итоге у нас появляется лишний код, что не очень хорошо.

Кроме лишнего кода мы получаем еще парочку инструментов - tslint + codelyzer, karma + jasmine и protractor для e2e.

Убедимся что наша библиотека работает и проходит linter

```cmd
npm test mylib
npx ng lint mylib
```

И тут мы видим еще одну проблему - для тестирования используется Chrome. Я ничего против него не имею, но на билд серверах его на 90% не будет. Почему не использовали тот же Puppeteer - не понятно. Но это ладно, это мы потом заменим, а вот где документация (я имею ввиду что-то вроде [storybook](https://github.com/storybooks/storybook))? Это же библиотека ui компонентов, здесь она просто должна быть. Тем более что команда Angular придерживается коробочного подхода. Будем считать нам просто оставили свободу маневра, что тоже не плохо.

Очень хорошо, что библиотека имеет собственный tsconfig.lib.json и karma.config.js файлы, так что мы можем изменять настройки как хотим не задевая соседние проекты.

Подведем итоги:

Плюсы

* Быстрый старт нового проекта
* Единообразный подход

Минусы

* Лишний код в проекте
* Очевидные вещи нужно допиливать руками

Ничего критичного, продолжаем копать дальше.

## Разработка

Кое-какие компоненты у нас уже есть "из коробки", хотелось бы на них посмотреть. Как это сделать? Здесь есть два варианта. Или ставить storybook, о котором я уже упоминал, или воспользоваться основным проектом для просмотра (вот он и пригодился). Для этого нам нужно сбилдить библиотеку и сделать импорт библиотечного модуля.

<spoiler title="немного кода">

```cmd
npx ng build mylib
```

```javascript
import { MylibModule } from "mylib";

...

@NgModule({
  declarations: [
    AppComponent,
  ],
  imports: [
    BrowserModule, MylibModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
```

```cmd
npm start
```

</spoiler>

И вот оно счастье - наша библиотека подключена и работает! Но есть нюанс - а где watch режим для библиотеки? Ответ такой: пока не подвезли, собирайте руками. Watch появится только в angular/cli 6.2+. И для для этого придется добавить новый флаг в tsconfig.json

tsconfig.json

```json
"angularCompilerOptions": {
    "enableResourceInlining": true,
}
```

А после этого запускать билд c флагом watch:

```cmd
ng build mylib --watch
```

Если же вы используете Angular/cli младшей версии - значит вам не повезло. А вот почему такую важную функцию не добавили сразу в момент релиза не понятно.

Ну ладно, проехали watch режим, давайе создадим новый компонент.

```cmd
npx ng generate component some-nice-image --project mylib
```

Из-за того, что библиотека не наш основной проект, приходится использовать флаг проекта, но можно запустить тот же код и без него, если вызывать команду из-под папки библиотеки, так что не страшно. 

Теперь под src создадим папку assets, добавим какаую картинку и пересоберем библиотеку (чувствуете интригу?) и вместо картинки увидим 404 в консоли. Наш файл с изображениями не попал в бандл библиотеки, потому что "из коробки" это тоже не работает. Конечно, это можно обойти, (например [вот так](https://github.com/ng-packagr/ng-packagr/issues/123#issuecomment-398559176)), но как то это не правильно.

Зато, из-коробки должен работать tree-shaking. Давайте создадим еще один компонент в библиотеке но не будем использовать его в основном проекте. Собираем **основной проект** в продакш режиме

```cmd
npx build --prod
```

И видим, что размер бандла не изменился. Tree-Shaking с библиотеками действительно работает!

Теперь неплохо было бы попробовать поставить какую-то зависимость. Поскольку каждый проект имеет свой собственный package.json нам нужно сначала перейти в папку библиотеки и выполнять команду npm install

```cmd
npm i -D @drag13/when-do
npm i @drag13/round-to
```

Я специально поставил их по разному что бы проверить как потом с этим справится упаковщик. Все ставится без проблем. Пробуем собрать и получаем предупреждение

> Distributing npm packages with 'dependencies' is not recommended. Please consider adding @drag13/round-to to 'peerDependencies'or remove it from 'dependencies
 
*Распространение npm пакетов с зависимостями не желательно. Пожалуйста, подумайте что бы добавить зависимость @drag13/round-to к peerDependencies или вообще убрать ее из зависимостей*

а затем и ошибку:
> Dependency @drag13/round-to must be explicitly whitelisted

*Зависимость @drag13/round-to должна быть явно добавлена в белый список*

Вот это уже интересно, by design, библиотека не хочет иметь прямых зависимостей. Пробуем переместить нашу завиимость в секцию peerDependencies и собраться заново - вуаля, все работает. Но это значит порядок установки сторонних библиотек теперь другой. Сначала ставим зависимость на основной модуль, потом, ручками добавляем в секцию peerDependencies библиотеки. Наверное, если бы я читал мануалы, я бы это знал?

Остальное работает так же как и в обычном Angular проекте.

Коротко подведем итоги:

Плюсы:

* Работаем в знакомом окружении со знакомыми командами.
* Есть tree-shaking из коробки

Минусы:

* Для "посмотреть компонент" нужно использовать целый проект.
* Пока еще нет watch режима
* Не поддерживаются assets

И, наконец, переходим к публикации

## Публикация

Вот тут все прямо хорошо. Для публикации angular/cli использует уже неполохо зарекомендовавший себя [ng-packgr](https://github.com/ng-packagr/ng-packagr) который самостоятельно собирает наш код в пригодный для публикации npm пакет оставляя за бортом настройку package.json файла (а это не мало), минификацию, упаковку в разные форматы (например в UMD). Для того, что бы опубликовать свой пакет (или посмотреть что там внутри) нужно выполнить три команды

```cmd
npx ng build --prod
cd dist/mylib
npm publish
```

Если вы не хотите паблишить, замените команду publish на pack и давайте заглянем внутрь. Первое что нас интересует это package.json, который выглядит совсем не так как оргинальный package.json нашей библиотеки:

<spoiler title="немного кода">

```json
{
  "name": "mylib",
  "version": "0.0.1",
  "peerDependencies": {
    "@angular/common": "6.1.6",
    "@angular/core": "6.1.6",
    "@drag13/round-to": "^0.10.1"
  },
  "devDependencies": {
    "@drag13/when-do": "^1.1.0"
  },
  "dependencies": {
    "tslib": "^1.9.0"
  },
  "main": "bundles/mylib.umd.js",
  "module": "fesm5/mylib.js",
  "es2015": "fesm2015/mylib.js",
  "esm5": "esm5/mylib.js",
  "esm2015": "esm2015/mylib.js",
  "fesm5": "fesm5/mylib.js",
  "fesm2015": "fesm2015/mylib.js",
  "typings": "mylib.d.ts",
  "metadata": "mylib.metadata.json",
  "sideEffects": false
}
```

</spoiler>

Как видим, packagr не стал удалять наши devDependencies, хотя некоторые так делают. Кроме того радует количество форматов, которые поддерживает описаны в package.json (пусть я и половины их не знаю), и наличие минифицированного бандла с кодом библиотеки.

Перейдем к выводам

Плюсы:

* Удобство
* Продуманность

Минусов:

* Не заметил

## Итоги

Команда Angular сделала очень интересную попытку унифицировать создание библиотек компонент и упростить разработчикам жизнь. Но, на мой взгляд, результат получился сыроватым. Да, стартовать проект и публиковать свой код стало очень удобно. Но это не отменяет того, что библиотека от Angular Team не самостоятельна by design, что привносит изрядную долю неудобства. Безусловно, с ними можно жить, но мне кажется им еще есть куда расти. И когда поменяется сам подход, я уверен, мы получим отличный инструмент для разработки.