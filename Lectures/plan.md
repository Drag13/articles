# YGHT

## Code should work

Давайте поговорим о том, что мы ожидаем от кода. Ну, для начала, он должен работать. Звучит конечно очевидно, но каждый из нас когда-то пытался или успешно запушил код, который даже не собирается. Второй момент - код должен корректно работать с некорректными ситуациями. Т.е. ловить ошибки. Но давайте пока вернемся к первому пункту и немного поговорим об этом.

Периодически мне попадает задача которую я понятия не имею как делать. Ну т.е. вообще. И тут меня сразу тянет начать писать какие-то абстракции, какую то инфраструктуру, что бы оттянуть момент реальной работы. Так вот, это не правильно. Код должен работать. Я знаю что я повторяюсь, но это важный момент. Если вы не знаете как решать задачу - не надо бросаться создавать интерфейсы, модули и вот это все. Так вот, это плохая идея которая закончится тем, что у вас закончится время, а вы никуда не продвинетесь. Запоминте, плохо работающий код, во много раз лучше хорошего, но не работающего кода. Сделайте сначала работающий прототип. Пусть он будет хромой, кривой и несчастный, зато когда с вас спросят - вы сможете сказать что решение уже есть, осталось его интегрировать. И перепишите его как надо. Если вы знаете как делать задачу - делайте ее хорошо. Если не знаете - решите ее хоть как-то.

И тут есть важный момент. Я бы хотел что бы вы поняли. Это не призыв писать плохой код. Код должен быть хороший. Это призыв к First Thing First - сначала код работает, потом рефакториться.

Итак, код у нас есть, он даже работает. Вернее, "работает". Давайте посмотрим на простой пример:

``` c#
public string Do(int x)
{
    using (WebClient xx = new WebClient())
    {
        return xx.DownloadString("https://some.super.url");
    }
}
```

Это замечательный пример "работающего" кода. Почему? Потому, что он не не учитывает, что рано или поздно, наш ендпоинт отвалиться. Этот пример не учитывает так называемые edge case - пограничные, "плохие случаи". Когда вы начинаете писать код, задумайтесь о том, что может пойти не так. На самом деле я сейчас говорю не только об удаленных вызовах, а обо всех ресурсах которые находятся вне зоны вашего контроля - пользовательский ввод, посторонние файлы или файлы настроек, сетевые соединения. Все что может сломаться, сломается в самый неподходящий момент и единственное что вы можете с этим сделать - быть к этому готовым настолько, насколько это возможно. Ловите ошибки и пишите их в лог.

К сожалению, не все проблемы настолько очевидны. Есть целый ряд проблемных мест которые почти гарантированно порождают баги. Например работа с локалью, с часовыми поясами. Это боль и крики "на моей машине все работает".

Подсумируем. Сначала заставьте код рабоать, потом сделайте его хорошим и не забывайте про edge cases и обработку ошибок.

Теперь поговорим о поддержке кода.

Код должен работать. Что, звучит сильно очевидно? Ну да, есть такое, но не спешите с выводами. Во-первых я уверен, что каждый из вас когда нибудь запушит на ремоут неработающий код. А во-вторых работающий код это чуть больше чем просто "работающий" код. На самом деле я бы хотел поговорить о двух вещах.

Первое, да, код должен работать. Я знаю что я повторяюсь, но это важный момент. Допустим есть задача которую вы не то что бы представляете как делать. И вместо того что бы заняться исследованием проблемы, попробовать сделать свой PoC вы начинаете делать декомпозицию, создавать какие то слои абстракции или писать инфраструктурный код. Так вот, это плохая идея которая закончится тем, что у вас закончится время, а вы никуда не продвинетесь. Запоминте, плохо работающий код, во много раз лучше хорошего, но не работающего кода. Сделайте сначала работающий прототип. Пусть он будет хромой, кривой и несчастный, зато когда с вас спросят - вы сможете сказать что решение уже есть, осталось его интегрировать. И перепишите его как надо. Если вы знаете как делать задачу - делайте ее хорошо. Если не знаете - решите ее хоть как-то.

Но давайте сразу договоримся. Это не призыв говнокодить, это скорее способ как выкрутиться из сложной ситуации с наименьшими потерями. В любом случае, код вам нужно будет переписать или привести в порядок.

Второй момент заключается в том, что есть работающий код и есть "работающий" код. Давайте посмотрим на этот пример:

``` c#
public string Do(int x)
{
    using (WebClient xx = new WebClient())
    {
        return xx.DownloadString("https://some.super.url");
    }
}
```

Это замечательный пример "работающего" когда. Почему? Потому, что он не не учитывает, что рано или поздно, этот ендпоинт отвалиться. Этот пример не учитывает так называемые edge case - пограничные, "плохие случаи". Когда вы начинаете писать код, задумайтесь о том, что может пойти не так. На самом деле я сейчас говорю не только об удаленных вызовах а обо всех ресурсах которые находятся вне зоны вашего контроля - пользовательский ввод, посторонние файлы или файлы настроек, сетевые соединения. Все что может сломаться, сломается в самый неподходящий момент и единственное что вы можете с этим сделать - быть к этому готовым настолько, насколько это возможно.

Вернемся к нашему премеру. Теперь, когда мы знаем проблему, ее легко исправить просто обернув рискованный вызов в try/catch

``` c#
public string Do(int x)
{
    using (WebClient xx = new WebClient())
    {
        try
        {
            return xx.DownloadString("https://some.super.url");
        }
        catch (Exception e)
        {
            L(e);
            throw;
        }
    }
}
```

К сожалению, не все проблемы настолько очевидны. Есть целый ряд проблемных мест которые почти гарантированно порождают баги. Например работа с локалью, с часовыми поясами это боль и крики "на моей машине все работает".

Итак, подсумируем. Сначала заставьте код рабоать, потом сделайте его хорошим и не забывайте про edge cases и обработку ошибок.

## Code should be maintainable

Второе требование к хорошему коду это про поддержку. Поддержка понятие сложное, но я бы включил сюда два требования - код должен легко читаться и легко изменяться. Так, кто пишет комменты на русском? Никто не пишет? Замечательно. В общем одна из проблем это код на не английском языке. Не надо так. У меня был кусок кода с классами на Норвежском языке и я просто не мог выговорить их названия. Это было печально.

Вообще, легкость чтения это про именование (но не только). Именование классов, методов переменных. Их названия должны нести смысловую нагрузку и давать понять, что же делаете класс не смотря в код. Возьмем наш предыдущий пример. Что делает метод Do? Никто не знает. Но, достаточно поменять его название на GetUserName и все становится лучше. Аналогично с названиями переменных в виде x и xx. Не надо так. Правда есть общепринятые исключения ввиде e (exception), i,k - счетчики циклов, n - размерность и несколько еще.

Опять же, для примера, возьмите свой код, который вы написали месяц назад и попробуйте его бегло прочесть. Вы понимаете что там происходит? Если да - я вас поздравляю. Если нет, значит у вас проблема с читаемостью кода.

Вообще, есть такая интересная цитата:

«There are only two hard things in Computer Science: cache invalidation and naming things.» (C) Phil Karlton

Есть только две проблемы в Computer Science : инвалидация кеша и именования. И, в этой цитате есть большая доля правды.

Вторая составляющая читабельного кода это его сложность или структура. Да, сейчас я говорю про тех, кто любит писать шесть вложеных ифов, или вписывать колбек в колбек колбека внутри колбека. Пожалейте ваших коллег и самих себя. Спустя неделю вам придется буквально продираться сквозь этот код что бы что-то в нем исправить или добавить. По возможности придерживайтесь плоской структуры кода с небольшим количеством ветвлений, а значимые блоки кода выделяйте в методы, даже если не собираетесь их потом переиспользовать.

Теперь поговорим об еще одной сложной вещи - о том что хороший код легко менять. Кому знаком термин Big ball of mud? Если кому то не знаком - посмотрите на картинку. Каждый модуль зависит от каждого модуля и изменения контракта в одном месте скорее всего приведет к пришествию полярной лисички или, как минимум, к очень длительному дебагу. Что с этим делать? У меня есть несколько советов:

* Избегайте циклических зависимостей
* Групируйте функциональность в модули
* Следите за потоком данных
* Не допускайте большого количества зависимостей у класса

И рисуйте. Просто нарисуйте на листочке, как ваши данные обрабатываются приложением и какие классы для этого используются. Это поможет вам понять переусложенные места до того как это все станет непоправимо.

Да, и еще. Старайтесь придерживаться единого стиля принятого в команде. Это касается и форматирования, и подходов к решению задачи. Не надо использовать ~~ для округления, даже если это быстрее. Команда это не оценит. И начиная писать новый код, всегда смотрите в проект, возможно что-то из нужного вам уже реализовано и это можно переиспользовать.

## Code should be performant enough

Наверное все слышали, что преждевременные оптимизации это зло. Это правда, но правда так же и то, что вы должны знать свой инструмент и не писать на нем так, что бы веб клиент загружал core I7 на 60%. Давайте снова обратимся к нашему примеру. Казалось бы с ним все хорошо и там нечего оптимизировать. Но это не так. Если присмотреться, то мы увидим синхронное выполнение загрузки по сети. Это I/O операция которая, в этом случае, заблокирует наш поток до своего выполнения. В десктопных приложениях это приведет к подвисшему юаю, в серверных, в бесполезной резервации памяти и исчерпания ресурсов ThreadPull-а. Т.е. мало того что вы бесполезно расходуете память (напомню на каждый процесс нам выделюят память под стек), но и заставляете ThreadPull создавать новые потоки (что не так уж и быстро) вместо того что бы их освобождать. Конечно, эту проблему решить легко - использовать асинхронные операции. Но я говорю не конкретной проблеме. Я говорю о принципе - знайте свой инструмент и не создавайте проблем на пустом месте.

## Be tested with reasonable coverage

Это еще одна холиварная тема, но давайте ее тоже коснемся. Зачем нам вообще нужен Code Coverage и тесты? В идеальном мире - не нужны. В идеальном мире код пишут без багов, а требования никогда не меняются. Но мы живем в далеко не идеальном мире, поэтому тесты нам нужны для того, что бы быть уверенными что код работает действительно правильно (там нет багов) и что код работает по-прежнему правильно, после того как что-то поменялось. Значит ли это, что тесты должны покрывать все что только возможно? Нет, не значит. Во-первых это занимает время, а времени всегда не хватает. Во-вторых тесты так же становятся вашей кодовой базой за которой надо приглядывать и время от времени поправлять. И в третьих это не приносит значимой пользы, потому что заветный 100% код ковер ничего не гарантирует. Вы все равно где-то что-то не учтете. Так, что, ура!? Тесты можно не писать? И снова нет, тесты писать нужно. Но нужно учиться понимать, какие конкретно вещи должны быть покрыты тестами, а какие нет. Например бизнес логика должна быть покрыта тестами. Нет смысла тестировать, что если вы присвоете свойству значение оно таки присвоится. А вот проверить вычисляемый флаг зависящий от этого свойста уже будет иметь некоторый смысл. Так же имеет смысл проверять сложные операции над данными, математические трансформации. Пограничные (помните мы говорили о них в начале) случаи и ошибки.