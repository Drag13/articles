# TypeScript это не только про аннотацию типов – примеры из практики.

Всем привет, меня зовут Виталий и мы с вами уже знакомы по моей прошлой статье о [Дия Сити](https://dou.ua/forums/topic/35346/). Но сегодня я не хочу говорить о политике или бизнесе. Сегодня я хочу поговорить о TypeScript и зачем он нужен. Казалось бы, в 2021 году говорить об этом несколько поздновато. TypeScript достаточно известен, завоевал свою популярность и много у кого используется. Однако несмотря на это, много, где он используется как бы в пол силы. Простейшая аннотация типов, проверка на null и всё. Поэтому я принес несколько интересных, сугубо практических кейсов что бы показать, что TS может куда больше.

Кратенько о себе: с TS работаю больше 5 лет, любил, страдал (до ненависти дело так и не дошло, но бывало матерно) и вот сейчас на стадии дружбы. Если готовы - берите кофе, впереди будет мало текста и много кода. Мы поговорим о подмножествах, проекциях и динамическом выведении типов.

## Сужение примитивов

_Коан про термины_

_Однажды, прогуливаясь по морскому порту, Ученик спросил у Мастера:
\- Зачем нужен TypeScript, если у нас есть здравый смысл?
В ответ Мастер указал на только что пришвартовавшихся иностранных моряков, и попросил Ученика поприветствовать их.
Ученик с достоинством поклонился в сторону новоприбывших. Оскорбленные моряки набросились на Ученика и избили его._

Давайте начнем с простого. Представьте себе, что у нас есть некая функция, которая принимает на вход ключ, достает из словаря по ключу перевод и возвращает его. Какой будет тип этого ключа? Скорее всего – `string`. Но, понятно, что не каждый `string` является допустимым ключом – нам точно не нужна вся британская энциклопедия, да и опечатки никто не отменял.

Решать эту проблему можно по-разному. Например, если перевода не существует можно бросить исключение (пользователи будут рады). Можно исключение не бросать, вернуть тот же ключ, а факт отсутствия ключа залогировать, чтобы потом выяснить что пошло не так. В любом случае, о том, что случилась проблема мы узнаем постфактум, а, хотелось бы заранее.

И тут у TypeScript есть очень элегантное решение – если тебе не нужен весь string, то скажи об этом честно и просто объяви подмножество:

```ts
type TranslationKey = 'grey';
function translate(key: TranslationKey){...}
```

Благодаря этому очень просто приему мы получаем сразу несколько преимуществ:

- Что попало в метод уже не передать - мы защищены от опечаток и ключей к которым еще не готовы на этапе билда
- Когда какой-то ключ поменяется (`grey` -> `gray`) мы сразу увидим все места где нужно обновить код
- Работает IntelliSense - переиспользовать ключи стало намного проще, не надо каждый раз лезть и искать как же этот `landing_bid_ad_imageblock_subheader` пишется

Этот же прием можно использовать если нам обязательно нужно провалидировать некое значение, например почтовый адрес пользователя:

```ts
type Email = string;
const sendEmail = (email: Email)=> {...}
sendEmail('fake@email'); // fails
```

Теперь, если мы попытаемся передать в метод `sendEmail` просто какую-то строку, TypeScript заставит нас ее проверить написав [гард](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types):

```ts
// don't use in production please
const isValidEmail = (maybeEmail: unknown): maybeEmail is Email =>
  typeof maybeEmail === "string" && /^\S+@\S+$/.test(maybeEmail);
```

А, написав тесты на гард, мы будем уверенны что ничего не упустили.

## Производные от типов

_Коан про типы_

_Однажды, идя в храм на вершине высокой горы, Ученик спросил у Мастера:
\- зачем нужен TypeScript, если его не существует в RunTime?
В ответ Мастер толкнул Ученика и тот, не устояв на ногах, с криком покатился вниз в ущелье. Не дожидаясь, пока крики стихнут, Мастер продолжил путь._

С примитивами мы разобрались, теперь я хочу показать еще одну возможность которой часто пользуюсь - создание нового типа на основе существующего. В С# мы обычно расширяем типы, а вот в TS мы можем создавать новые типы на основе существующих:

```ts
type NotEmptyString = string;
type User = { name: NotEmptyString };
type Dto<T> = { [key in keyof T]: unknown };
type UserDto = Dto<User>;
```

Сначала я описал доменную модель, с которой готов работать. Для этого примера я создал тип `User`, с единственным полем `name` которое должно содержать не пустую строку. Но, поскольку я не очень-то доверяю постороннему сервису, из которого приходят данные я хочу ответ от сервера провалидировать. Для этого я создал производный тип `UserDto`, в котором честно объявил, что я понятия не имею что же нам пришлют. Теперь я, а также все кто придет после, будем вынуждены проверить данные перед их использованием.

Естественно, с помощью этого подхода можно написать и сам валидатор:

```ts
type DtoValidator<T> = {
  [key in keyof T]: (v: unknown) => v is T[key];
};

const isNotEmptyString = (v: unknown): v is NotEmptyString =>
  typeof v === "string" && v.length > 0;

const userValidator: DtoValidator<User> = {
  name: isNotEmptyString,
};
```

Самое прекрасное здесь то, что, когда мы расширим доменную модель новым полем, TS автоматически напомнит нам, что это поле тоже нужно ~~взболтать~~ проверить.

На моем проекте мы используем этот подход для валидации форм. Есть модель формы, а на ее основе строится модель валидатора. Когда поля формы меняются (что периодически бывает) TypeScript подсказывает, где мы прошляпили.

## Динамическая модификация типов

_Коан про смысл_

_Однажды, гуляя ухоженным монастырским парком, Ученик спросил у Мастера:
\- Зачем нужен TypeScript, если его можно заменить на JSDoc?
В ответ Мастер указал на пирамиду стоящих друг на друге камней и попросил вопрошающего выбить нижний камень. Ученик всей силой навалился на основание. Увидев, как шатается их любимая скульптура, монахи избили Ученика палками._

Этот трюк может быть особенно актуален если вы используете контексты в React, но сама идея будет работать везде. TS позволяет выводить новые типы "на лету", исходя из данных, которые вы передаете. Звучит запутанно, так что давайте посмотрим на примере.

Напишем функцию, которая приветствует пользователя:

```ts
type User = { firstName: string };
type Greetings = { greetingText: string };
const getGreetings = ({ firstName, greetingText }: User & Greetings) =>
  `${greetingText}, ${firstName}!`;
```

Очевидно, что имя пользователя у нас появится в рантайме, а вот текст самого приветствия может быть статичным. Можно написать функцию высшего порядка, которая будет внедрять `greetingText` в `getGreetings`

```ts
const greeterFactory = () => (user: User) =>
  getGreetings({ ...user, greetingText: "Hello" });

const greeter = greeterFactory();

greeter({ firstName: "Vitalii" });
```

Все хорошо, но это частное решение, а хотелось бы иметь общее, которое бы:

- Работало с произвольными типами
- Убирало из требуемого типа те поля, которые уже содержаться во внедренном объекте

Наивная реализация могла бы выглядеть так:

```ts
function factory<TModel, TResult, TInjected extends Partial<TModel>>(
  callback: (m: TModel) => TResult,
  inject: TInjected
) {
  return (m: Omit<TModel, keyof TInjected>) => callback({ ...inject, ...m });
}
```

Однако компилироваться она не будет, потому что я допустил любопытную ошибку:

```ts
factory((m: { greeting: string; name: string }) => m.name, {
  greeting: "hello",
  name: "Vitalii",
})("Joker");
```

Поскольку тип внедренного объекта полностью перекрывает требуемый тип, то итоговый тип может быть любым, даже строкой. Это явно не то, что мы бы хотели. И хорошо, что TypeScript оказался достаточно умным что бы это словить. Поэтому [код придется переписать](https://stackoverflow.com/a/70334649/5575595):

```typescript
function factory<
  TCallback extends (arg: any) => any,
  TModel extends Parameters<TCallback>[0],
  TInjected extends Partial<TModel>
>(callback: TCallback, injected: TInjected) {
  return function <TProps extends Omit<TModel, keyof TInjected>>(
    props: TProps extends object ? TProps : never
  ): ReturnType<TCallback> {
    return callback({ ...injected, ...props });
  };
}

const greeter = (_: { greeting: string; name: string }) => "";

// "Argument of type 'string' is not assignable to parameter of type 'never'"
const failed = factory(greeter, {
  greeting: "hello",
  name: "Vitalii",
})("Joker");

// // Works with full IntelliSense support.
const working = factory(greeter, {
  greeting: "hello",
})({ name: "test" });
```

Теперь все работает как ожидается, хотя _есть нюанс_. В реальном мире, как в `injected` так и в `props` может объект с куда большим количеством полей и это стоит иметь ввиду. 

Для нас этот подход пригодился, когда мы писали свои коннекторы к стору в реакте. В результате, в компонент нужно было передавать только те поля, которых нет в сторе, остальные он «возьмет» сам, а TypeScript проверит что мы не забыли пробросить недостающие. Поскольку все объекты под нашим контролем, нюанс о котором я упоминал проблемой не был.

## Итоги подведем

Как видите, TypeScript это нечто большее чем просто аннотация типов. Он позволяет очень просто создавать подмножества, проекции, выводить типы на лету и многое другое. Несмотря на то, что в runtime TypeScript отсутствует, правильно написанные типы вполне могут уберечь от неожиданного поведения и даже подсказать потенциальные промахи.

С другой стороны, некоторые вроде бы простые решение на TypeScript [не работают](https://www.typescriptlang.org/play#code/GYVwdgxgLglg9mABAZzgWwKYDFzXmACgEMAnAcwC5EBvIq5KEmMMgGkQCN7HmyBfAJTUAUIkQB6cYgAqACxjJECxBhhRZGEoigBPAA4YAJogAGDJiwDaAXROI4WgLSIA7mtnaNiWUQgBrKgIAIiIggB8gjiCBGwA6RFEJKQAhECgldLQYMll0nwA3DHt1TUQ-DB1FIkUXDAAbOoBCRIgEBjKKxQBeRAB5DgArDGhY8sricgEAbmE+YWFJRDA4F0Q6jCgAckU0InLPIurkEDQ9WAREYCIYOop51rB2tB0AQXITjDB0npExOkQgqhMEFWIkuAD1LwQS0qEFwBgAB4GaBGIKzeaLZbpEprOBwPSuG51RC+KAgIgNHQZTREKBFOCFLTBUIRKIRCDRGwLKQcNIHby+crGXQGVxwEB1YxYkkQVrgdLAByeWnCIHYXDnQjPN5kD5faZAA). Ошибки бывают не понятны и не очевидны, особенно на начальном этапе (да и чего таить греха - потом тоже). Начальная разработка на TypeScript тоже идет медленнее, так как нужно спроектировать и описать типы, а потом еще и исправить там, где ты промахнулся.

Но, несмотря ни на что, удобство поддержки, которое обеспечивает TypeScript, того стоит. Набирать новых людей в команду и даже самому возвращаться к модулю, с которым ты не работал хотя бы месяц - намного легче и приятнее. Главное, это сохранять баланс, как говорил главный персонаж одной очень философской игры.

Всем хороших праздников!
