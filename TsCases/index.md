# TypeScript это не только про аннотацию типов – примеры из практики.

Всем привет, меня зовут Виталий и мы с вами уже знакомы по моей прошлой статье о [Дия Сити](https://dou.ua/forums/topic/35346/). Но сегодня я не хочу говорить о политике или бизнесе. Сегодня я хочу поговорить о TypeScript и зачем он нужен. Казалось бы, в 2021 году говорить об этом несколько поздновато, TypeScript вполне себе наступил. Однако я часто вижу, что он сильно недооценивается, и используется на уровне JsDoc - для простейшей аннотаций типов. Поэтому я принес несколько интересных, сугубо практических кейсов что бы показать, что TS может куда больше.

Кратенько о себе: с TS работаю больше 5 лет, любил, страдал (до ненависти дело так и не дошло, но бывало матерно) и вот сейчас на стадии дружбы. Если готовы - берите кофе, впереди будет мало текста и много кода. Мы поговорим о подмножествах, проекциях и динамическом выведении типов.

## Сужение примитивов

_Коан про термины_

_Однажды, прогуливаясь по морскому порту, Ученик спросил у Мастера:
\- Зачем нужен TypeScript, если у нас есть здравый смысл?
В ответ Мастер указал на только что пришвартовавшихся иностранных моряков, и попросил Ученика поприветствовать их.
Ученик с достоинством поклонился в сторону новоприбывших. Оскорбленные моряки набросились на Ученика и избили его._

Давайте начнем с простого. Представьте себе, что у нас есть некое поле, которое содержит имейл пользователя. Какой тип этого поля? Зависит от языка, но в С# и JS это скорее всего будет `string`. Но на самом деле это не всегда так, потому что не каждый String является валидным имейлом, а отправлять почту куда попало нам бы не хотелось.

Решить эту проблему можно создав соответствующую структуру, которая будет гарантировать валидность имейла. Однако постоянно писать `email.value` утомляет. И если для сложных структур, которым нужно хранить некое дополнительное состояние или функциональность это оправдано, тот тут скорее всего нет. Поэтому в TypeScript можно поступить проще - сузить тип `string` до типа `email`:

```ts
type Email = string;
const sendEmail = (email: Email)=> {...}
sendEmail('fake@email'); // this code will fail
```

Теперь, если мы попытаемся передать в метод `sendEmail` какую-то строку, TypeScript заставит нас ее проверить.

На моем проекте мы именно так поступили с ключами для переводов (у нас мультиязычное приложение). Теперь их легко писать, так как работает IntelliSense, невозможно опечататься так как упадет билд и можно безопасно удалять не боясь что где-то отвалится перевод.

Кстати, так же можно сузить и `number`, а с помощью черной магии можно описать почти настоящий тип `byte`:

```ts
type Mapped<
  N extends number,
  Result extends Array<unknown> = []
> = Result["length"] extends N
  ? Result
  : Mapped<N, [...Result, Result["length"]]>;

type Byte = Mapped<256>[number];
const a: Byte = 255; // OK
const b: Byte = 256; // fails, out of range
```

## Производные от типов

_Коан про типы_

_Однажды, идя в храм на вершине высокой горы, Ученик спросил у Мастера:
\- зачем нужен TypeScript, если его не существует в RunTime?
В ответ Мастер толкнул Ученика и тот, не устояв на ногах, с криком покатился вниз в ущелье. Не дожидаясь, пока крики стихнут, Мастер продолжил путь._

С примитивами мы разобрались, теперь я хочу показать еще одну возможность которой часто пользуюсь - создание нового типа на основе существующего. В С# мы обычно расширяем типы, а вот в TS мы можем создавать производные, например вот так:

```ts
type NotEmptyString = string;
type User = { name: NotEmptyString };
type Dto<T> = { [key in keyof T]: unknown };
type UserDto = Dto<User>;
```

Сначала мы описываем доменную модель, с которой наш код готов работать. Пусть это будет тип `User`, с единственным полем `name` которое должно содержать строку, да еще и обязательно не пустую. Но, с бекенда может прийти все что угодно (например, если бекенд не наш) и мне бы хотелось быть уверенным что мы входящий объект провалидировали. Для этого мы создаем производный тип `UserDto`, в котором постулируем печальный факт: мы не знаем, что нам придет. И теперь мы, а также те, кто придет после нас, будем уже вынуждены валидировать ответ от сервера.

Естественно, с помощью этого подхода можно написать и сам валидатор:

```ts
type DtoValidator<T> = {
  [key in keyof T]: (v: unknown) => v is T[key];
};

const isNotEmptyString = (v: unknown): v is NotEmptyString =>
  typeof v === "string" && v.length > 0;

const userValidators: DtoValidator<User> = {
  name: isNotEmptyString,
};
```

Самое прекрасное здесь то, что, когда мы расширим доменную модель новым полем, TS автоматически напомнит нам, что это поле тоже нужно проверить перед употреблением.

На моем проекте мы используем этот подход для валидации форм. Есть модель формы, а на ее основе составляется модель валидатора. Когда поля формы меняются (что периодически бывает) TypeScript подсказывает что мы упустили.

## Динамическая модификация типов

_Коан про смысл_

_Однажды, гуляя ухоженным монастырским парком, Ученик спросил у Мастера:
\- Зачем нужен TypeScript, если его можно заменить на JSDoc?
В ответ Мастер указал на пирамиду стоящих друг на друге камней и попросил вопрошающего выбить нижний камень. Ученик всей силой навалился на основание. Увидев, как шатается их любимая скульптура, монахи избили Ученика палками._

Этот трюк может быть особенно актуален если вы используете контексты в React, но сама идея будет работать везде. TS позволяет выводить новые типы "на лету", исходя из данных которые вы передаете. Звучит запутанно, так что давайте посмотрим на примере.

Напишем функцию, которая приветствует пользователя:

```ts
type User = { firstName: string };
type Greetings = { greetingText: string };
const getGreetings = ({ firstName, greetingText }: User & Greetings) =>
  `${greetingText}, ${firstName}!`;
```

Очевидно, что имя пользователя у нас появится в рантайме, а вот текст самого приветствия может быть статичным. Можно написать функцию высшего порядка, которая будет внедрять `greetingText` в `getGreetings`

```ts
const greeterFactory = () => (user: User) =>
  getGreetings({ ...user, greetingText: "Hello" });

const greeter = greeterFactory();

greeter({ firstName: "Vitalii" });
```

Все хорошо, но это частное решение, а хотелось бы иметь общее, которое бы:

- Работало с произвольными типами
- Убирало из требуемого типа те поля, которые уже содержаться во внедренном объекте

Наивная реализация могла бы выглядеть так:

```ts
function factory<TModel, TResult, TInjected extends Partial<TModel>>(
  callback: (m: TModel) => TResult,
  inject: TInjected
) {
  return (m: Omit<TModel, keyof TInjected>) => callback({ ...inject, ...m });
}
```

Однако компилироваться она не будет, потому что я допустил любопытную ошибку:

```ts
factory((m: { greeting: string; name: string }) => m.name, {
  greeting: "hello",
  name: "Vitalii",
})("Joker");
```

Поскольку тип внедренного объекта полностью перекрывает требуемый тип, то итоговый тип может быть любым, даже строкой. Это явно не то, что мы бы хотели. И хорошо, что TypeScript оказался достаточно умным что бы это словить. Поэтому [код придется переписать](https://stackoverflow.com/a/70334649/5575595):

```typescript
function factory<
  TCallback extends (arg: any) => any,
  TModel extends Parameters<TCallback>[0],
  TInjected extends Partial<TModel>
>(callback: TCallback, injected: TInjected) {
  return function <TProps extends Omit<TModel, keyof TInjected>>(
    props: TProps extends object ? TProps : never
  ): ReturnType<TCallback> {
    return callback({ ...injected, ...props });
  };
}

const greeter = (_: { greeting: string; name: string }) => "";

// "Argument of type 'string' is not assignable to parameter of type 'never'"
const x = factory(greeter, {
  greeting: "hello",
  name: "Vitalii",
})("Joker");

// Argument of type '{ xxxx: string; }' is not assignable to parameter of type 'Omit<UserGreetings, "greeting">'.
// Object literal may only specify known properties, and 'xxxx' does not exist in type 'Omit<UserGreetings, "greeting">'.
const x2 = factory(greeter, {
  greeting: "hello",
})({ xxxx: "test" });

// Argument of type '{}' is not assignable to parameter of type 'Omit<UserGreetings, "greeting">'.
// Property 'name' is missing in type '{}' but required in type 'Omit<UserGreetings, "greeting">'.
const x3 = factory(greeter, {
  greeting: "hello",
})({});

// // Works with full IntelliSense support.
const x4 = factory(greeter, {
  greeting: "hello",
})({ name: "test" });
```

Для нас этот подход пригодился, когда мы писали свои коннекторы к стору в реакте. В результате, в компонент нужно было передавать только те поля, которых нет в сторе, остальные он «возьмет» сам, а TypeScript проверит что мы не забыли пробросить недостающие.

## Итоги подведем

Как видите, TypeScript это нечто большее чем просто аннотация типов. Он позволяет очень просто создавать подмножества, проекции, выводить типы на лету и многое другое. Несмотря на то, что в runtime TypeScript отсутствует, правильно написанные типы вполне могут уберечь от неожиданного поведения и даже подсказать потенциальные промахи.

С другой стороны, некоторые интуитивно понятные решения на TypeScript пишутся сложно. Ошибки бывают не понятны и не очевидны, особенно на начальном этапе (да и чего таить греха - потом тоже). Начальная разработка на TypeScript тоже идет медленнее, так как нужно спроектировать и описать типы, а потом еще и исправить там, где ты промахнулся.

Но, несмотря ни на что, удобство поддержки, которое обеспечивает TypeScript, того стоит. Набирать новых людей в команду и даже самому возвращаться к модулю, с которым ты не работал хотя бы месяц - намного легче и приятнее. Главное, это сохранять баланс, как говорил главный персонаж одной очень философской игры.

Всем хороших праздников!
