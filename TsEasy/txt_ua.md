TypeScript - всегда сначала.

В одной из старый книг Пелевина (еще до того как уровень его абстракций и аллюзей забрел в гости к Безумному Шляпнику) была замечательная миниатюра про лифт и слоган Джим Бима который в вольном переводе я вынес в заголовок. Миниатюра конечно многогранна, но одна из ее идей о том, что кем бы ты ни стал, что бы не пережил

Ну что ж, попробуем показать что и "нечитаемое гавно" может быть полезно.

## Установка

## Начальные условия

Недавно Тимур Шемсединов выложил код, который он дает студентам для рефакторинга. Я пойду тем же путем, возьму код на JS и перепишу его на TS что бы вы сами могли оценить сложность изменений и их пользу. Единственное условие - когда будете оценивать, представьте себе:

- Над проектом работает хотя бы 3 человека
- Код не одноразовый, его надо поддерживать.

Итак, начнем с начального кода:

```javascript
const API = { USER: `/user` };

async function fetchApi(url, options, mapper) {
  const response = await Promise.resolve({
    url,
    method: options.method,
    data: JSON.stringify({ name: "Jhon", secondName: "Dou" }),
  });
  const result = mapper(JSON.parse(response.data));
  return result;
}

const userMapper = (data) => ({
  fullName: `${data.name} ${data.secondName}`,
});

(async function () {
  const result = await fetchApi(API.USER, { method: "POST" }, userMapper);

  console.log(result.fullName);
})();
```

Как видите, код очень простой. Есть функция `fetchApi` которая по урлу достает некие данные из апи, есть функция маппера которая трансформирует сырые данные во то, что ожидает на фронт и вызов всего этого счастья. Казалось бы, какую пользу может тут принести TS. Давайте посмотрим.

## Intellisense

Начнем с удобства. Если сейчас в редакторе написать `result.` то VsCode ничего нам не подскажет и это не очень удобно, надо лезть в маппер и смотреть что он возвращает. А потом еще и не опечататься. Давайте эот исправим:

Сначала мы делаем метод fetchApi параметризируем, добавляя `<T>`:

```ts
async function fetchApi<T>(url, options, mapper): Promise<T>;
```

А теперь, при вызове fetchApi мы указаываем ожидаемый тип:

```ts
const result = await fetchApi<{fullName:string}>(
```

Все, этого уже достаточно для VsCode для того что бы включился IntelliSense:

## Фиксим косяк

IntelliSense это конечно хорошо, но сейчас наш маппер может возвращать что угодно, хоть строку. И мы получим ситуацию даже хуже чем до этого, потому что IS будет утверждать одно, а фактически там может быть что-попало. Т.е. контроль ложится на ревьювера, а нагрузку на ревьювера, которым может быть и вы, хотелось бы уменьшить. Что бы это исправть, зададим нашему мапперу тип с помощью конструкции `(data:any)=> T`. 

```ts
async function fetchApi<T>(url, options, mapper:(data:any)=> T):Promise<T> {
```

Все, больше менять ничего не надо, этого уже достаточно. Теперь, если вы ошибетесь и вернете из маппера не то, что указали при вызове fetchApi, TS об этом предупредит:

`Property 'fullName' is missing in type '{ fulName: string; }' but required in type '{ fullName: string; }'`

## А что такое options

Посмотрите на сигнатуру функции `fetchApi`. Что такое options? Наверное это объект, но что там еще есть? IntelliSense снова молчит, надо лезть глазами в код функции и смотреть что не есть хорошо. Давайте и ему дадим тип:

```ts
async function fetchApi<T>(url, options: {method: string}, mapper:(data:any)=> T):Promise<T> {
```

Уже лучше, теперь IntelliSense нам подскажет, что нам надо указать HTTP глагол. Но есть нюанс. HTTP глаголов всего ничего, а string не исчерпаем как океан. Снова придется следить самому за тем, что бы глагол указывали правильно. С другой стороны, эту проблему можно тоже переложить на плечи TS-а:

```ts
async function fetchApi<T>(url, options: {method: 'POST' | 'PUT'}, mapper:(data:any)=> T):Promise<T> {
```

Здесь мы убили одним выстрелом сразу двух зайцев. Улучшили DX и уберегли товарища от возможной ошибки.

## Бесконечный API 

Еще один интересный момент это урл, который мы используем что бы вызвать API. С одной стороны мы все сделали красиво - вынесли все ендпоинты в константы. С другой стороны где гарантия того, что наши коллеги будут эти константы использовать? Почему бы и тут что-то не улучшить, тем более что все просто, достаточно заменить объект на enum.

```ts
enum API { USER = `/user` };
async function fetchApi<T>(
    url:API, 
    options: {method: 'GET'|'POST'}, 
    mapper:(data:any)=> T):Promise<T> {
```

Теперь наш метод fetchApi будет принимать только элементы перечисления.

На этом все что я хотел показать в рамках TS это не больно.

Но если вам стало интересно, то у меня в загашнике остался еще один любопытный приемчик.

## Uknown 

Давайте посмотрим на функцию mapper. Обратите внимание, насколько беспардонно мы обращаемся с аргументом data - не проверили на null, читаем из него что попало. Выглядит не очень и на код ревью это может всплыть. Но зачем доводить дело до код ревью, если можно кое-что сделать заранее. 

Для начала давайте напишем тип для нашей функции маппера:

```ts
type DtoMapper<T> = (data: unknown) => T;
```

Здесь нет ничего нового, кроме использования типа `unknown` для аргумента функции. Unknown не дает использовать переменную без приведения типа. И это дает возможность намекнуть разработчику, что неплохо было бы этот аргумент как то проверить