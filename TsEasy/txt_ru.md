# Как использовать TypeScript с минимумом усилий

Когда пишешь статью, в голове возникают самые разные сценарии о том, как она будет воспринята. Не знаю как у других авторов, но у меня такое происходит всегда, и чем ближе статья к завершению, тем сценарий обычно мрачнее.

Поэтому публикуя прошлую статью о TS я предполагал, что она может быть воспринята "не очень". Но все мои предположения крутились вокруг тривиальности примеров. Услышать что TS не нужен в 2021, я просто не ожидал. Ну вот не укладывается в моей голове это. И тут я увидел один очень интересный комментарий:

> Увы в TS очень сильно перегнули палку с диктатурой, а более мягкого инструмента посередине между jsdoc и TS по сути нет, если d.ts не считать. Мягких опциональных аннотаций типов было бы достаточно- тот же jsdoc, но в инлайн семантике.

А потом еще один:

> Фанаты TS часто забывают, что в большинстве баги типизации, что ловит ts, быстро находятся и без него. А меташума в коде добавляется много)

(На самом деле полезных комментариев было больше, я просто взял те которые сработали первыми)

И понял что похоже я таки перегнул палку. А почему? Да потому что оба комментария прекрасно демонстрируют что за деревьями не видно леса, за типами не видно пользы. Поэтому я решил это исправить. В этой статье я покажу как можно использовать TypeScript без страданий и, одновремнно, с пользой.

## Сначала все было хорошо

Идея у меня простая. Давайте возьмем какой-то валидный код на JS и попробуем переписать его на TS. Задача - получить максимум пользы за минимум усилий. А вы оцените что получилось в комментариях. Только давайте сразу договоримся - когда будете оценивать, исходите из того, что над кодом работает хотя бы 3 человека и его нужно поддерживать на протяжении скажем двух лет.

Для примера я подготовил следующий код:

```javascript

```

Тут все достаточно тривиально - это просто обертка над стандартным fetch в которой мы сразу вытягиваем JSON, делаем маппинг, или можем настроить какое-то общее поведение что бы не копипастить его по всему коду. Думаю каждый из нас делал такое хотя бы раз. 

Теперь давайте посмотрим, какую пользу нам может принести TS и как сложно это будет.

## Talk is cheap

Итак, у нас есть код, он рабочий, будем его переписывать под TS. С целью уменьшения ентропии я опускаю раздел о том, как поднять тестовый проект, но если нужно - вот ссылочка на рабочую репу.

Первым делом, переименовываем .js в .ts и пробуем его выполнить (для таких эксперементов я обычно использую `ts-node`, очень удобно выполнять скрипты на TS без необходимости использовать Babel или что-то еще).

И конечно же все валится. TS выдает ошибку: `Parameter 'url' implicitly has an 'any' type`. Решить это можно тремя путями. Первый, самый сложный - указать везде правильные типы. Второй, по-проще, указать везде any. Но мы договорились прилагать минимум усилий, поэтому используем еще более простой финт. Идем в `tsconfig.json`, и добавляем: `"noImplicitAny": false`\*.

Запускаем проект заново и теперь работает. Т.е. мы взяли валидный JS и не меняя ни единой строки кода, не добавляя никаких типов, смогли его выполнить ts-ом\*\*.

Правда пользы с этого нет, а хотелось бы. Давайте попробуем что-то улучшить.

\* `"noImplicitAny": false` считается не очень хорошей практикой, так как вы больше не видите где TS потерял типы. Явное `any` лучше `"noImplicitAny": false` но эти рассуждения выходят за рамки статьи.

\*\* Для запуска более сложного кода одного флага `"noImplicitAny": false` скорее всего не хватит. Поэтому здесь я оставляю ссылку на [документацию](https://www.typescriptlang.org/tsconfig)

## Типизируем result

Начнем с удобства. Если сейчас в редакторе написать `result.` то VsCode ничего нам не подскажет и это не очень удобно, надо лезть в маппер и смотреть что он возвращает. Давайте это исправим:

Сначала мы делаем метод fetchApi параметризируем, добавляя `<T>`:

```ts

```

А теперь, при вызове fetchApi мы указываем ожидаемый тип:

```ts

```

Все, этого уже достаточно для VsCode для того что бы включился IntelliSense:

IMG

## Вокруг сплошной самообман

IntelliSense это конечно хорошо, но сейчас наш маппер может возвращать что угодно, хоть строку. И мы получим ситуацию даже хуже чем она
была до этого, потому что IntelliSense будет утверждать одно, а фактически там может быть что угодно. Придется это контролировать сначала девелоперу, а потом ревьюверам, что не есть гут так как увеличивает время ревью и вообще добавляет человеческтй фактор.

Что бы это исправть, давайте просто свяжем тип который возвращает маппер и тип который мы ожидаем от метода fetch:

```ts

```

Все, больше менять ничего не надо, этого уже достаточно\*. Теперь, если вы ошибетесь и вернете из маппера не то, что указали при вызове fetchApi, TS об этом предупредит:

`Property 'fullName' is missing in type '{ fulName: string; }' but required in type '{ fullName: string; }'`

\* На самом деле есть более красивое решение которое позволяет вообще не указывать тип при вызове `fetch`. Достаточно указать TS что бы он использовал тип, который возвращает маппер. Но это требует некоторой манипуляции с типами, а мы договаривались не усложнять.

## И снова у матрицы сбой

Теперь посмотрим на сигнатуру функции `fetchApi`. Вы помните структуру options? Я только частично. Хотелось бы что бы TS нам помог, но описывать весь тип я как-то не горю желанием. Поэтому есть два варианта. Первый - написать тип самостоятельно. Второй - не утруждать себя и просто использовать чужой. Выбор очевиден:

```ts

```

Однак теперь возникла проблема. В типе `RequestInit` body это строка, а мы передаваем туда объект. TypeScript негодует. Решить проблему можно по-разному. Самый простой способ - прикастить body к any: `body: { id: 5 } as any`. Это сработает, но так придется писать каждый раз при вызове `fetch`. Т.е. в перспективе это как раз сложный вариант. Второй вариант это заменить тип `RequestInit` на свой. Это может быть полезно, если вы хотите ограничить параметры, которые можно использовать во время запроса (например запретить передавать заголовки). Но писать свой тип - противоречит изначальным условиями статьи. К счастью есть золотая середина - мы можем модфицировать\* чужой тип:

Вот и все, теперь все снова в порядке.

\* С помощью `.d.ts` файлов доступна глобальная модификация типа без создания промежуточного звена. Так, например, поступет Vuex что бы типизовать стор.

## Ленивое API

Еще один интересный момент это урл, который мы используем что бы вызвать API. С одной стороны мы все сделали красиво - вынесли все эндпоинты в константы. С другой стороны, новому человеку это все придется рассказывать, да и в PR тщательнее смотреть. Зачем тратить свои силы, если можно возложить эту задачу на TypeScript? Тем более что решается это тривиально, достаточно заменить на объект на перечисление (enum)

```ts

```

Теперь ендпоинт это не просто какая-то строка, а элемент перечисления и TS проконтролирует корректность использования.

На этом у меня все что я хотел показать в рамках этой статьи. Но все примеры которые я привел, они, как бы это сказать, больше про DX, про удобство разарботки. Это конечно и важно и полезно, но как то скудно и даже немного обидно за инструмент. Поэтому, перед тем как закончить, я хочу показать еще один пример.

## А что-нибудь нормальное сыграть можете?

Давайте посмотрим на функцию mapper. Обратите внимание, насколько вольно мы обращаемся с аргументом data - не проверили на null, читаем из него что попало и как попало, а это чревато проблемами в рантайме. Можем ли мы сделать так, что бы подтолкнуть коллег к более осторожному обращению с ответами от сервера? Можем!

Для начала давайте напишем тип для нашей функции маппера:

```ts
type DtoMapper<T> = (data: unknown) => T;
```

Здесь нет ничего нового, кроме использования типа `unknown` для аргумента функции. Unknown это не магия, он просто не дает использовать переменную без приведения типа:

И это дает нам возможность намекнуть нам, что перед использованием объекта было бы неплохо его как то проверить. И для этого в TypeScript есть TypeGuard:

```typescript
const isUserDto = (d: any): d is { name: string; secondName: string } => {
  return (
    d != null &&
    typeof d === "object" &&
    typeof d.name === "string" &&
    typeof d.secondName === "string"
  );
};
```

Что в TypeGuard-ах хорошего, так это то, что они заставляют вас выносить проверку объекта в отдельную функцию, которую легко менять и так же легко покрывать тестами. Т.е. сама идея подталкивает писать код более модульным, что не может не радовать.

Теперь осталось связать все воедино:

```typescript
const userMapper: DtoMapper<{ fullName: string }> = (data) => {
  if (!isUserDto(data)) {
    throw new Error("user dto is not in appropriate format");
  }

  return { fullName: `${data.name} ${data.secondName}` };
};
```

Вот теперь у меня действительно все

## В заключение

Спасибо за ваше внимание, надеюсь, что статья получилась полезной и мне удалось показать, что TS это не только меташум в коде, но и удобство.

Отдельно хочу заметить, что все подходы, которые я показал, более-менее независимы друг от друга. Вы можете имплементировать только ту часть, которую посчитаете действительно полезной для себя. Большой плюс TypeScript в том, что он не следует принципу "все или ничего". Вы можете использовать его именно таким способом, что бы получить максимальную пользу за минимум усилий.

```cmd
npm init -y;
npm i node-fetch
npm i typescript ts-node -D
npx tsx --init
```

Теперь создайте папку src и положите туа

Теперь, для удобства, в секцию scripts добавим команду start:

```json
{
  "start": "ts-node src/index"
}
```

И попробуем выполнить
