В последнее время я немного увлекся производительностью веб-приложений, как делать их быстрее, как оптимизировать загрузку и так далее. И решил, почему бы мне не попроовать сделать аудит хабру? Тем более что там юди сидят умные, значит все будет не просто. Что из этого получилось - смотрите под катом.

## Этап первый - "По-верхам"

Заходим на сайт в анонимном режиме (важно что бы никакие расширения нам не мешали). Открываем devtools, потом вкладку сеть (network), включаем disable-cache, и запускаем в режиме Empty-Cache and Hard Reload и смотрим на результат:

![unlimitedloading]()

Весь сайт был загружен за 3.42 секунды, что достаточно хорошо. DomContentLoaded (DCL) вообще отработал за 1.5 секунды что выглядит еще лучше. При всем при этом, сайт делает 182 запроса и грузит 13МБ ресурсов. Это значит что либо команда Хабра - гении (вполне может быть), статью надо заканчивать прямо тут (и проситься к нам в команду за кофе и печеньки), либо ограничить пропускную способность сети и попробовать еще раз. Включаем режим Fast 3g и смотрим еще так раз:

![fast3gloading]()

DCL ухудшился до 3.66 секунд что все еще достаточно приемлемо. А вот окончательно сайт загрузился за безбожные 72 секунды, что уже более-менее логично. Ребята провели хорошую работу что бы максимально быстро показать нам контент, а все не критичное оставили грузиться в фоне. Окей, теперь посмотрим почему мы грузились 72 секунды. Отсортируем все запросы по времени загрузки и найдем четыре фотографии размером по 2.1, 2.1, 1.2, и 1 мб. Вот они эти лица подозрительной наружности:

![longloadingimages]()

Тут сразу можно указать на две проблемы: нет ограничений по размеру изображений, и не используется перекодирование изображений в современные форматы - jpeg2000 или webp. Правда это не так страшно (помним про 3.66), потому что изображения, в отличии от css и javascript не блокируют рендер страницы. Давайте посмотрим какие еще ресурсы тянет Хабр - пройдемся по типам и отсортируем по размеру:

Top3 javaScript:

Стили:

Шрифты:

Как видим, стилей ребята грузят относительно не немного (позже мы примерно проверим сколько из них действительно используется на странице), шрифт вообще один (за что отдельное спасибо тому, кто отстоял факт использования только одного шрифта), а вот со скриптами все интересно. Давайте разберемся с ними подробнее.

Самый большой скрипт - prebid.js, весит 290кб в пожатом виде, или аж! 981кб в не пожатом виде. Это очень много. Но, его интеграция сделана грамотно, и загрузка этого скрипта не останавливает загрузку страницы. Так что, кроме сжигантия трафика, вреда он вроде бы не приносит.

Второй скрипт - vendor.js гораздо интереснее. Судя по водопаду загрузки, он, вероятно, блокирует нам загрузку страницы. Если мы откроем html, который грузится изначально, мы найдем там и подтверждение:

```html
<script src="https://dr.habracdn.net/habrcom/javascripts/1559218850/vendors.bundle.js"></script>
```

Но и тут Хабр показывает себя с хорошей стороны. Вместо того, чтобы положить скрипт в head и заблокировать загрузку основного контента, скрипт положен почти в самый низ страницы. Поэтому, хотя он и блокирует DomContentLoaded, но основной контент уже отрендерен и читаемый. Этот прием известен уже давно и не удивительно что ребята его знают, но, тем не менее - молодцы. В общем становится понятно, что команда свой хлеб ест не даром, проблемы обходятся умело.

Время идти глубже.

## Этап второй - профилируем ручками

Запустим профайлинг. Перепроверим что стоит slowdown fast3g (потому запустим еще раз, но без ограничений) и смотрим что происходит. Наст интересует FMP, и, на всякий случай DCL. Выделяем область от старта до FMP и смотрим summary chart. Опа - все происходит довольно быстро - 1.57 сек до FMP (это быстро), но почти все это время мы ничего не делали... Полезная нагрузка заняла всего 315мс, все остальное время основной потом браузера простаивал. Это уже звоночек. В идеале, основной поток браузера работает постоянно - парсит html, css, строит layout, выполняет js. А тут - ничего. Почему. Потому что браузеру просто нечего делать. Помните мы урезали траффик? Браузер разослал запросы и просто ждет их выполнения. Если мы откроем верхний чарт network все станет сразу понятно. Наш враг - main.bundle.css. Проблем с css несколько. Во-первых, он блокирует рендер страницы. Т.е. пока мы его не загрузим ничего дальше не будет. Во-вторых, пока мы не построим CssOm мы не имеем права выполнять JS (загружать можно, парсить можно, а вот выполнять нельзя, а значит и нельзя рендерить дом дальше). 

С 2секнду до, примерно, 3.15 мы грузили CSS. Потом, за 12мс браузер распарсил CSS и тут же пошел парсить внедренный в страницу JS. Потом снова остановился почти на 150 мс (ждал пока же мы догрузим jquery.min.js). И после этого уже взялся за работу всерьез - разобрался с загруженным jquery (20мс), распарсил raven.js(4мс), распарсил почти всю страницу (36мс), пересчитал стили (28мс), рассчитал лаяут (78ms + 8ms) и, наконец, за ms раскрасил нам страницу. Тут мы и получили наш FMP. Дальше мы парсим страницу, парсим скрипты - привет никому не нужные (publishertag.js, gpt.js которые влезли в main thread до DCL), немного поигрались со стилями (что вызвало небольшую потерю времени из-за перерасчета лаяута) и начали ждать vendors.bundle.js (он кстати минифицирован, несмотря на отсутствие min). На то что бы дождаться вендоров мы, почти вхолостую, потратили еще около 1.1 секунды. Правда параллельно с ним мы загружали еще и main.bundle.js (который, кстати, загрузился быстрее), поэтому не все так плохо. Дальше все снова пошло хорошо. Распарсили вендоров, распарсили основной бандл, распарсили Math.Jax, и наконец то допарсили страницу и получили DCL! Правда тут же сработал какой-то хендлер который на моем I7 остановил основной поток на 80мс (т.е. сайт как бы подвис на 80ms). Сейчас мы этого почти не заметили, но на слабом процессоре, теоретически, это может быть заметно.

Фух... Давайте выдохнем. Что тут можно сказать. Опять-таки, несмотря на то как это выглядит все достаточно неплохо. Основные проблемы нам доставили:

* Большой простой браузера
* Долгая загрузка CSS 
* Синхронная загрузка jquery vendors и main бандлов.

Что с этим можно сделать? 

* Попробовать использовать preconnect/prefetch. Возможно, они помогут начать браузеру грузить ресурсы раньше и, соответственно, чуть раньше начать работать.
* CSS проверить, а нужно ли нам так много. Возможно, часть не используется. Выделить критическую часть и заинлайнить.
* Основные скрипты. Тут вопрос - а нужны ли нам эти скрипты до DCL вообще? Что мы такого должны сделать со страницей ДО DCL этими скриптами? Если эти задачи могут подождать, пометить их defer атрибутом, и сбросить в самый низ. Если нет - думать дальше.

Теперь давайте повторим тоже самое уже без ограничений на ширину канала. Картина уже гораздо лучше:
0.452 секунды до FMP, простой всего! 13ms. DCL - 953ms, простой 15ms. Вот как выглядит загрузка моей мечты. Вот только это получилось из-за того, что я не убрал кеширование. Попробуем то же самое, но без кэша:

Все тоже достаточно хорошо, FMP - 980ms, Idle 217ms (т.е. около 20% времени). DCL 1384ms, Idle почти не поменялся. Но, тут неожиданно много времени ушло на Rendering - 400ms для FMP. Из них 200ms ушло на пересчет стилей и перерасчет лаяута. Причем самое обидное то, что вычислить паршивца который в этом виноват не так просто. Перед тем как начать пересчитывать стили отрабатывает raven.js но с чего бы системе для ловли ошибок клиента лезть в стили непонятно. Network намекает на шрифты, но это не доказуемо. В общем без кода разобраться сложно.

Кстати, еще один интересный момент. Помните рекламные скрипты, которые влезли в наш рендер? Если открыть их в самой странице, они выглядят вполне отлично

<script src="https://www.googletagservices.com/tag/js/gpt.js" async></script>
<script src="https://static.criteo.net/js/ld/publishertag.js" async></script>

Помечены как async, т.е. неблокирующие, не создающие очередь, мечта, а не скрипты. И даже с таким абсолютно правильным подходом они умудрились немного подпортить нам картину. Почему? Потому что асинхронные скрипты выполняются после загрузки самого скрипта, а нам бы надо - после загрузки страницы. Так что помните, что иногда даже async загрузка скриптов может испортить перфоманс. 

Итак, ручную разборку мы сделали. Теперь пусть потрудятся другие.

## Тяжелая артилерия

Начем с того же dev tools и запустим Lighthouse - desctop, performance only, nothrotling, clear storage. Получаем фантастические цифры (даже с отключенным кешем)

При этом lighthouse жалуется на:

* Устаревший формат изображений (предлагает использовать webp, jpeg2000, etc)
* Количество DOM node – их аж слишком много: 2533
* Большой траффик (5мб)
* Не корректную политику кеширования - отсутствуют заголовки кеширования на 23 ресурсах
* Использование document.write 
* И, наконец, на использование уязвимой версии jQuery.

Все понятно, все по-делу.

Теперь запустим тоже самое на fast3g и тут все гораздо хуже.

* Значительно выросли проблемы, связанные с изображениями. LH снова предлагает использовать next-gen форматы изображения, но теперь, по его мнению, это сэкономит нам 11 условных секунд
* Появилась проблема с кодировкой изображений
* Выросла проблема с блокирующими рендер ресурсами. Причем тут всплыли два синхронных микроскрипта adriver.js и advertise.js по 50байт каждый, которые я посчитал несущественными и пропустил при ручном разборе.
* Появилось предложение порезать CSS с намеком на то, что используется всего 5 кб из 45.
* Впервые появилась проблема слишком загруженного main thread. Так Script Evaluation занял 8.5 секунд, работа со стилями и лайоут - 2.35с. Это действительно много.
* И, тоже впервые, появилась проблема слишком большого количества javascript на сайте. Так, например, raven.min.js 
raven.js, которую я специально игнорировал все это время. 

Что такое raven.js? Это такая система, которая помогает отслеживать ошибки возникающие на клиентской стороне. Естественно, что она нужна как можно раньше. Поэтому ребята вставили загрузку raven.js скрипта в head, причем загрузка это блокирующая. Это привело к тому, что на слабой машине, только script evaluation для raven.js занял 2186ms.

Если честно, именно с этого и нужно было начинать наше исследование. Сначала мы выявляем проблемы автоматически, чиним самые большие и только потом, если этого не хватает, лезем руками. Но, поскольку, обычно автоматического разбора хватает, мало кто лезет смотреть руками. А мне хотелось показать именно это. 

Какие выводы можно вынести отсюда? Хабр хорошо работает на быстром интернете и мощных машинах. Смещение в сторону чего-то по-бюджетнее может вызвать проблемы. Проблемы вызваны:

* Большими изображениями
* Большим объёмом DOM
* Большим количеством JavaScript на странице.

Было сделано очень много что бы эти проблемы не мешали быстрому появлению контента, однако для слабых машин это все еще будет проблема (например, блокирующий raven.js и другие).

И наконец, попробуем еще один известный инструмент - [https://www.webpagetest.org/](https://www.webpagetest.org/) Зайдем туда, выберем habr как цель, выставим test location - warsaw, ограничение 4g (мы такого еще не пробовали)

Здесь все очень подробно. Можно посмотреть сколько времени (и кому) требовалось что бы отрезолвить DNS, сколько ушло на установку соединения и так далее. Кроме того, нам показывают факт переадресации (желтый фон запроса), которой оказывается неожиданно много, что не есть хорошо. По каждому запросу можно посмотреть подробности. Так, например, если мы нажмем на habr.com мы увидим что ответа от браузера мы ждали аж 1351 ms, а вот загружали его всего 286 ms, что намекает (а может и не намекает) на то что сервера довольно загружены (или просто загрузка страницы требует от бекенда слишком много). Можно так же посмотреть злополучный main.bundle.css - оказывается, это первое обращение к dr.habracdn.net что, приводит к необходимости выполнить dns lookup (200ms, правда кто-то же должен). Плюс 400ms мы просидели на SSL Negotiation. И еще 572ms от нас морозился сервер в надежде что мы сами уйдем наверное. Итого, впустую было потрачено больше чем секунду (а все это время мы ждали...). Webpagetest так же, прямо на чарте, показывает когда выполнялся JS. Вот raven.js все время загрузки страницы, что то активно делал (блокируя при этом основной поток). Еще есть отличная вкладка image analysis которая, показывает, как и сколько можно сэкономить если перепожать изображения. Фото какого-то рыжего котейки в PNG весит 1.4МБ, а в webp + downscaling (да читерство, но все же) - 17.7 KB. Для сравнения, фото в таком же разрешении, но все еще в png весит 154кб. 

Какие выводы можно сделать отсюда:

* Мы увидели большое количество переадресаций. Это ест время, с этим надо разбираться.
* Увидели довольно длинный SSL negotiation 200-400 ms. Ну как, длинный, в принципе это нормальное время но Habr делает уж очень много запросов так что в сумме получается приличное время.
* Увидели огромнейший чарт загрузкок который позволяет оценить, насколько большое количество запросов делает Habr (и при этом все равно основной контент отдается довольно быстро)
 
Теперь перейдем к выводам.

* Сайт перегружен. Большой DOM, большое количество рекламных скриптов, большое количество запросов.
* Есть проблемы с изображениями. Большой размер, неоптимальный формат. Все это есть трафик и долго грузится.
* Есть проблемы с habrastorage и переадресациями (я вообще не понимаю откуда ноги растут)
* Сайт быстро рендериться на хорошем соединение и мощной машине, но все довольно быстро ухудшается с уменьшением канала и падением производительности процессора. (Плюс у меня хорошая видеокарта, я не пробовал ее отключать, возможно там тоже что-то вылезет)

* При всем при этом, очевидно, что проведена хорошая работа по оптимизации. Сайт достаточно быстро грузит основной текст, остальное происходит уже после того, как мы видим текст. 

Итого: многое сделано, но еще есть куда расти и улучшаться. И поменьше бы трекеров/аналитики/рекламы, но это уже скорее мечты.


Полезные ссылки
* https://medium.com/web-standards/performance-metrics-ff23c213164e
* https://medium.com/reloading/javascript-start-up-performance-69200f43b201
* https://docs.google.com/presentation/d/1Lq2DD28CGa7bxawVH_2OcmyiTiBn74dvC6vn2essroY/edit#slide=id.g1a504e63c9_7_77
* https://www.2dogsdesign.com/webpagetest-waterfall/